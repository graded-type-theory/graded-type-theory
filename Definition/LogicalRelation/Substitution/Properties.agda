------------------------------------------------------------------------
-- Lemmata on valid substitutions
------------------------------------------------------------------------

{-# OPTIONS --hidden-argument-puns #-}

open import Definition.Typed.EqualityRelation
open import Definition.Typed.Restrictions
open import Graded.Modality

module Definition.LogicalRelation.Substitution.Properties
  {a} {M : Set a}
  {ğ•„ : Modality M}
  (R : Type-restrictions ğ•„)
  {{eqrel : EqRelSet R}}
  where

open EqRelSet {{...}}

open import Definition.Untyped M
  hiding (_âˆ·_) renaming (_[_,_] to _[_,_]â‚â‚€)
open import Definition.Untyped.Properties M
open import Definition.Typed R
open import Definition.Typed.Properties R
open import Definition.Typed.Weakening R
open import Definition.LogicalRelation R
open import Definition.LogicalRelation.Substitution R
open import Definition.LogicalRelation.Substitution.Irrelevance R
     using (irrelevanceSubstâ€²)
open import Definition.LogicalRelation.Irrelevance R
open import Definition.LogicalRelation.Properties R
import Definition.LogicalRelation.Weakening R as LR

open import Tools.Fin
open import Tools.Function
open import Tools.Level
open import Tools.Nat using (Nat)
open import Tools.Unit
open import Tools.Product
import Tools.PropositionalEquality as PE
open import Tools.Reasoning.PropositionalEquality

private
  variable
    k m n : Nat
    A Aâ‚ Aâ‚‚ B Bâ‚ Bâ‚‚ C Câ‚ Câ‚‚ t tâ‚ tâ‚‚ u uâ‚ uâ‚‚ v : Term _
    Î“ Î” : Con Term n
    Ïƒ Ïƒâ‚ Ïƒâ‚‚ Ïƒâ€² : Subst m n
    Ï : Wk k n
    l : TypeLevel
    âŠ¢Î” : âŠ¢ _
    âŠ©Î“ : âŠ©áµ› _

-- Valid substitutions are well-formed
wellformedSubst : âˆ€ {Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
      â†’ Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”
      â†’ Î” âŠ¢Ë¢ Ïƒ âˆ· Î“
wellformedSubst Îµ âŠ¢Î” [Ïƒ] = id
wellformedSubst ([Î“] âˆ™ [A]) âŠ¢Î” ([tailÏƒ] , [headÏƒ]) =
  wellformedSubst [Î“] âŠ¢Î” [tailÏƒ]
  , escapeTerm (projâ‚ (unwrap [A] âŠ¢Î” [tailÏƒ])) [headÏƒ]

-- Valid substitution equality is well-formed
wellformedSubstEq : âˆ€ {Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
      ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
      â†’ Î” âŠ©Ë¢ Ïƒ â‰¡ Ïƒâ€² âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ]
      â†’ Î” âŠ¢Ë¢ Ïƒ â‰¡ Ïƒâ€² âˆ· Î“
wellformedSubstEq Îµ âŠ¢Î” [Ïƒ] [Ïƒâ‰¡Ïƒâ€²] = id
wellformedSubstEq ([Î“] âˆ™ [A]) âŠ¢Î” ([tailÏƒ] , [headÏƒ]) ([tailÏƒâ‰¡Ïƒâ€²] , [headÏƒâ‰¡Ïƒâ€²]) =
  wellformedSubstEq [Î“] âŠ¢Î” [tailÏƒ] [tailÏƒâ‰¡Ïƒâ€²]
  , â‰…â‚œ-eq (escapeTermEq (projâ‚ (unwrap [A] âŠ¢Î” [tailÏƒ])) [headÏƒâ‰¡Ïƒâ€²])

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’âŠ¢[]â‰¡[] :
    {âŠ©Ïƒâ‚ : Î” âŠ©Ë¢ Ïƒâ‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“ â†’
    Î” âŠ©Ë¢ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” â†’
    Î” âŠ©Ë¢ Ïƒâ‚ â‰¡ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” / âŠ©Ïƒâ‚ â†’
    Î” âŠ¢ A [ Ïƒâ‚ ] â‰¡ A [ Ïƒâ‚‚ ]
  âŠ©áµ›â†’âŠ¢[]â‰¡[] {âŠ©Ïƒâ‚} âŠ©A âŠ©Ïƒâ‚‚ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ =
    â‰…-eq $ escapeEq (âŠ©A .unwrap _ âŠ©Ïƒâ‚ .projâ‚) $
    âŠ©A .unwrap _ âŠ©Ïƒâ‚ .projâ‚‚ âŠ©Ïƒâ‚‚ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚

-- Extend a valid substitution with a term
consSubstS : âˆ€ {l t A Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
           ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
           ([A] : Î“ âŠ©áµ›âŸ¨ l âŸ© A / [Î“])
           ([t] : Î” âŠ©âŸ¨ l âŸ© t âˆ· A [ Ïƒ ] / projâ‚ (unwrap [A] âŠ¢Î” [Ïƒ]))
         â†’ Î” âŠ©Ë¢ consSubst Ïƒ t âˆ· Î“ âˆ™ A / [Î“] âˆ™ [A] / âŠ¢Î”
consSubstS [Î“] âŠ¢Î” [Ïƒ] [A] [t] = [Ïƒ] , [t]

-- Extend a valid substitution equality with a term
consSubstSEq : âˆ€ {l t A Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
             ([Ïƒ]    : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
             ([Ïƒâ‰¡Ïƒâ€²] : Î” âŠ©Ë¢ Ïƒ â‰¡ Ïƒâ€² âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ])
             ([A] : Î“ âŠ©áµ›âŸ¨ l âŸ© A / [Î“])
             ([t] : Î” âŠ©âŸ¨ l âŸ© t âˆ· A [ Ïƒ ] / projâ‚ (unwrap [A] âŠ¢Î” [Ïƒ]))
           â†’ Î” âŠ©Ë¢ consSubst Ïƒ t â‰¡ consSubst Ïƒâ€² t âˆ· Î“ âˆ™ A / [Î“] âˆ™ [A] / âŠ¢Î”
               / consSubstS {t = t} {A = A} [Î“] âŠ¢Î” [Ïƒ] [A] [t]
consSubstSEq [Î“] âŠ¢Î” [Ïƒ] [Ïƒâ‰¡Ïƒâ€²] [A] [t] =
  [Ïƒâ‰¡Ïƒâ€²] , reflEqTerm (projâ‚ (unwrap [A] âŠ¢Î” [Ïƒ])) [t]

-- Weakening of valid substitutions
wkSubstS : âˆ€ {Î“ Î” Î”â€²} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”) (âŠ¢Î”â€² : âŠ¢ Î”â€²)
           ([Ï] : Ï âˆ· Î”â€² âŠ‡ Î”)
           ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
         â†’ Î”â€² âŠ©Ë¢ Ï â€¢â‚› Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”â€²
wkSubstS Îµ âŠ¢Î” âŠ¢Î”â€² Ï [Ïƒ] = lift tt
wkSubstS {Ïƒ = Ïƒ} {Î“ = Î“ âˆ™ A} ([Î“] âˆ™ x) âŠ¢Î” âŠ¢Î”â€² Ï [Ïƒ] =
  let [tailÏƒ] = wkSubstS [Î“] âŠ¢Î” âŠ¢Î”â€² Ï (projâ‚ [Ïƒ])
  in  [tailÏƒ]
   ,  irrelevanceTermâ€² (wk-subst A)
        (LR.wk Ï âŠ¢Î”â€² (projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))))
        (projâ‚ (unwrap x âŠ¢Î”â€² [tailÏƒ]))
        (LR.wkTerm Ï âŠ¢Î”â€² (projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))) (projâ‚‚ [Ïƒ]))

-- Weakening of valid substitution equality
wkSubstSEq : âˆ€ {Î“ Î” Î”â€²} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”) (âŠ¢Î”â€² : âŠ¢ Î”â€²)
             ([Ï] : Ï âˆ· Î”â€² âŠ‡ Î”)
             ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
             ([Ïƒâ‰¡Ïƒâ€²] : Î” âŠ©Ë¢ Ïƒ â‰¡ Ïƒâ€² âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ])
           â†’ Î”â€² âŠ©Ë¢ Ï â€¢â‚› Ïƒ â‰¡ Ï â€¢â‚› Ïƒâ€² âˆ· Î“ / [Î“]
                / âŠ¢Î”â€² / wkSubstS [Î“] âŠ¢Î” âŠ¢Î”â€² [Ï] [Ïƒ]
wkSubstSEq Îµ âŠ¢Î” âŠ¢Î”â€² Ï [Ïƒ] [Ïƒâ‰¡Ïƒâ€²] = lift tt
wkSubstSEq {Î“ = Î“ âˆ™ A} ([Î“] âˆ™ x) âŠ¢Î” âŠ¢Î”â€² Ï [Ïƒ] [Ïƒâ‰¡Ïƒâ€²] =
  wkSubstSEq [Î“] âŠ¢Î” âŠ¢Î”â€² Ï (projâ‚ [Ïƒ]) (projâ‚ [Ïƒâ‰¡Ïƒâ€²])
  , irrelevanceEqTermâ€² (wk-subst A) (LR.wk Ï âŠ¢Î”â€² (projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))))
                            (projâ‚ (unwrap x âŠ¢Î”â€² (wkSubstS [Î“] âŠ¢Î” âŠ¢Î”â€² Ï (projâ‚ [Ïƒ]))))
                            (LR.wkEqTerm Ï âŠ¢Î”â€² (projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))) (projâ‚‚ [Ïƒâ‰¡Ïƒâ€²]))

-- Weaken a valid substitution by one type
wk1SubstS : âˆ€ {F Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
            (âŠ¢F : Î” âŠ¢ F)
            ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
          â†’ (Î” âˆ™ F) âŠ©Ë¢ wk1Subst Ïƒ âˆ· Î“ / [Î“]
                            / (âŠ¢Î” âˆ™ âŠ¢F)
wk1SubstS [Î“] âŠ¢Î” âŠ¢F [Ïƒ] =
  wkSubstS [Î“] âŠ¢Î” (âŠ¢Î” âˆ™ âŠ¢F) (step id) [Ïƒ]

-- Weaken a valid substitution equality by one type
wk1SubstSEq : âˆ€ {F Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
              (âŠ¢F : Î” âŠ¢ F)
              ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
              ([Ïƒâ‰¡Ïƒâ€²] : Î” âŠ©Ë¢ Ïƒ â‰¡ Ïƒâ€² âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ])
            â†’ (Î” âˆ™ F) âŠ©Ë¢ wk1Subst Ïƒ â‰¡ wk1Subst Ïƒâ€² âˆ· Î“ / [Î“]
                            / (âŠ¢Î” âˆ™ âŠ¢F) / wk1SubstS [Î“] âŠ¢Î” âŠ¢F [Ïƒ]
wk1SubstSEq [Î“] âŠ¢Î” âŠ¢F [Ïƒ] [Ïƒâ‰¡Ïƒâ€²] =
  wkSubstSEq [Î“] âŠ¢Î” (âŠ¢Î” âˆ™ âŠ¢F) (step id) [Ïƒ] [Ïƒâ‰¡Ïƒâ€²]

-- Lift a valid substitution
liftSubstS : âˆ€ {l F Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
             ([F] : Î“ âŠ©áµ›âŸ¨ l âŸ© F / [Î“])
             ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
           â†’ (Î” âˆ™ F [ Ïƒ ]) âŠ©Ë¢ liftSubst Ïƒ âˆ· Î“ âˆ™ F / [Î“] âˆ™ [F]
                             / (âŠ¢Î” âˆ™ escape (projâ‚ (unwrap [F] âŠ¢Î” [Ïƒ])))
liftSubstS {Ïƒ = Ïƒ} {F = F} {Î” = Î”} [Î“] âŠ¢Î” [F] [Ïƒ] =
  let âŠ¢F = escape (projâ‚ (unwrap [F] âŠ¢Î” [Ïƒ]))
      [tailÏƒ] = wk1SubstS {F = F [ Ïƒ ]} [Î“] âŠ¢Î” (escape (projâ‚ (unwrap [F] âŠ¢Î” [Ïƒ]))) [Ïƒ]
      var0 = var (âŠ¢Î” âˆ™ âŠ¢F) (PE.subst (Î» x â†’ x0 âˆ· x âˆˆ Î” âˆ™ F [ Ïƒ ])
                                     (wk-subst F) here)
  in  [tailÏƒ] , neuTerm (projâ‚ (unwrap [F] (âŠ¢Î” âˆ™ âŠ¢F) [tailÏƒ])) (var x0)
                        var0 (~-var var0)

opaque

  -- A variant of liftSubstS.

  liftSubstSâ€² :
    {Ïƒâ‚ Ïƒâ‚‚ : Subst m n}
    {âŠ¢Î” : âŠ¢ Î”}
    {âŠ©Ïƒâ‚ : Î” âŠ©Ë¢ Ïƒâ‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”}
    (âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“)
    (âŠ©Ïƒâ‚‚ : Î” âŠ©Ë¢ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”) â†’
    Î” âŠ©Ë¢ Ïƒâ‚ â‰¡ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” / âŠ©Ïƒâ‚ â†’
    Î” âˆ™ A [ Ïƒâ‚ ] âŠ©Ë¢ liftSubst Ïƒâ‚‚ âˆ· Î“ âˆ™ A / âŠ©Î“ âˆ™ âŠ©A /
      âŠ¢Î” âˆ™ escape (âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒâ‚ .projâ‚)
  liftSubstSâ€² {A} {Ïƒâ‚} {âŠ¢Î”} {âŠ©Ïƒâ‚} âŠ©A âŠ©Ïƒâ‚‚ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ =
    case wk1SubstS _ _ _ âŠ©Ïƒâ‚‚ of Î» {
      âŠ©wk1Subst-Ïƒâ‚‚ â†’
    case conv (varâ‚€ (escape (âŠ©A .unwrap _ âŠ©Ïƒâ‚ .projâ‚)))
           (PE.subst
              (_ âˆ™ A [ Ïƒâ‚ ] âŠ¢_â‰¡ _)
              (wk1Subst-wk1 A)
              (âŠ©áµ›â†’âŠ¢[]â‰¡[] âŠ©A âŠ©wk1Subst-Ïƒâ‚‚
                 (wk1SubstSEq _ _ _ _ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚))) of Î» {
      âŠ¢0 â†’
      âŠ©wk1Subst-Ïƒâ‚‚
    , neuTerm
        (âŠ©A .unwrap _ âŠ©wk1Subst-Ïƒâ‚‚ .projâ‚)
        (var x0)
        âŠ¢0
        (~-var âŠ¢0) }}

-- Lift a valid substitution equality
liftSubstSEq : âˆ€ {l F Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
             ([F] : Î“ âŠ©áµ›âŸ¨ l âŸ© F / [Î“])
             ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
             ([Ïƒâ‰¡Ïƒâ€²] : Î” âŠ©Ë¢ Ïƒ â‰¡ Ïƒâ€² âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ])
           â†’ (Î” âˆ™ F [ Ïƒ ]) âŠ©Ë¢ liftSubst Ïƒ â‰¡ liftSubst Ïƒâ€² âˆ· Î“ âˆ™ F / [Î“] âˆ™ [F]
                             / (âŠ¢Î” âˆ™ escape (projâ‚ (unwrap [F] âŠ¢Î” [Ïƒ])))
                             / liftSubstS {F = F} [Î“] âŠ¢Î” [F] [Ïƒ]
liftSubstSEq {Ïƒ = Ïƒ} {Ïƒâ€² = Ïƒâ€²} {F = F} {Î” = Î”} [Î“] âŠ¢Î” [F] [Ïƒ] [Ïƒâ‰¡Ïƒâ€²] =
  let âŠ¢F = escape (projâ‚ (unwrap [F] âŠ¢Î” [Ïƒ]))
      [tailÏƒ] = wk1SubstS {F = F [ Ïƒ ]} [Î“] âŠ¢Î” (escape (projâ‚ (unwrap [F] âŠ¢Î” [Ïƒ]))) [Ïƒ]
      [tailÏƒâ‰¡Ïƒâ€²] = wk1SubstSEq [Î“] âŠ¢Î” (escape (projâ‚ (unwrap [F] âŠ¢Î” [Ïƒ]))) [Ïƒ] [Ïƒâ‰¡Ïƒâ€²]
      var0 = var (âŠ¢Î” âˆ™ âŠ¢F) (PE.subst (Î» x â†’ x0 âˆ· x âˆˆ (Î” âˆ™ F [ Ïƒ ])) (wk-subst F) here)
  in  [tailÏƒâ‰¡Ïƒâ€²] , neuEqTerm (projâ‚ (unwrap [F] (âŠ¢Î” âˆ™ âŠ¢F) [tailÏƒ])) (var x0) (var x0)
                         var0 var0 (~-var var0)

opaque

  -- Another variant of liftSubstS.

  liftSubstSâ€³ :
    {Ïƒâ‚ Ïƒâ‚‚ : Subst m n}
    {âŠ¢Î” : âŠ¢ Î”}
    {âŠ©Ïƒâ‚ : Î” âŠ©Ë¢ Ïƒâ‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    (âŠ©B : Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A)
    (âŠ©Ïƒâ‚‚ : Î” âŠ©Ë¢ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”) â†’
    Î” âŠ©Ë¢ Ïƒâ‚ â‰¡ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” / âŠ©Ïƒâ‚ â†’
    let âŠ¢A = escape (âŠ©A .unwrap _ âŠ©Ïƒâ‚ .projâ‚)
        âŠ¢B = escape (âŠ©B .unwrap _ (liftSubstS _ _ âŠ©A âŠ©Ïƒâ‚) .projâ‚)
    in
    Î” âˆ™ A [ Ïƒâ‚ ] âˆ™ B [ liftSubst Ïƒâ‚ ] âŠ©Ë¢ liftSubstn Ïƒâ‚‚ 2 âˆ· Î“ âˆ™ A âˆ™ B /
      âŠ©Î“ âˆ™ âŠ©A âˆ™ âŠ©B / âŠ¢Î” âˆ™ âŠ¢A âˆ™ âŠ¢B
  liftSubstSâ€³ {A} {B} {Ïƒâ‚} {Ïƒâ‚‚} {âŠ¢Î”} {âŠ©Ïƒâ‚} {âŠ©A} âŠ©B âŠ©Ïƒâ‚‚ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ =
    case escape (âŠ©A .unwrap _ âŠ©Ïƒâ‚ .projâ‚) of Î» {
      âŠ¢A[Ïƒâ‚] â†’
    case escape (âŠ©B .unwrap _ (liftSubstS _ _ âŠ©A âŠ©Ïƒâ‚) .projâ‚) of Î» {
      âŠ¢B[â‡‘Ïƒâ‚] â†’
    case wk1SubstS _ _ _ (wk1SubstS _ _ _ âŠ©Ïƒâ‚‚) of Î» {
      âŠ©wk2Subst-Ïƒâ‚‚ â†’
    case conv (varâ‚ âŠ¢B[â‡‘Ïƒâ‚])
           (PE.subst
              (_ âˆ™ A [ _ ] âˆ™ _ âŠ¢_â‰¡ _)
              (A [ wk1Subst (wk1Subst Ïƒâ‚) ]  â‰¡âŸ¨ wk1Subst-wk1 A âŸ©
               wk1 (A [ wk1Subst Ïƒâ‚ ])       â‰¡âŸ¨ PE.cong wk1 (wk1Subst-wk1 A) âŸ©
               wk1 (wk1 (A [ Ïƒâ‚ ]))          âˆ) $
            âŠ©áµ›â†’âŠ¢[]â‰¡[] âŠ©A
              (wk1SubstS _ _ âŠ¢B[â‡‘Ïƒâ‚] (wk1SubstS _ _ âŠ¢A[Ïƒâ‚] âŠ©Ïƒâ‚‚))
              (wk1SubstSEq _ _ _ _ (wk1SubstSEq _ _ _ _ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚))) of Î» {
      âŠ¢1 â†’
    case conv (varâ‚€ âŠ¢B[â‡‘Ïƒâ‚])
           (PE.subst
              (_ âˆ™ _ âˆ™ B [ _ ] âŠ¢_â‰¡ _)
              (wk1Subst-wk1 B)
              (âŠ©áµ›â†’âŠ¢[]â‰¡[]
                 {âŠ©Ïƒâ‚ = wk1SubstS {Ïƒ = liftSubst Ïƒâ‚}
                          (_ âˆ™ âŠ©A) _ _ (liftSubstS _ _ âŠ©A âŠ©Ïƒâ‚)}
                 âŠ©B
                 (wk1SubstS {Ïƒ = liftSubst Ïƒâ‚‚} (_ âˆ™ âŠ©A) _ âŠ¢B[â‡‘Ïƒâ‚] $
                  liftSubstSâ€² âŠ©A âŠ©Ïƒâ‚‚ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚)
                 (wk1SubstSEq {Ïƒ = liftSubst Ïƒâ‚} {Ïƒâ€² = liftSubst Ïƒâ‚‚}
                    (_ âˆ™ âŠ©A) _ _ (liftSubstS _ _ âŠ©A âŠ©Ïƒâ‚) $
                  liftSubstSEq _ _ âŠ©A _ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚))) of Î» {
      âŠ¢0 â†’
      ( âŠ©wk2Subst-Ïƒâ‚‚
      , neuTerm
          (âŠ©A .unwrap _ _ .projâ‚)
          (var (x0 +1))
          âŠ¢1
          (~-var âŠ¢1)
      )
    , neuTerm
        (âŠ©B .unwrap _ _ .projâ‚)
        (var x0)
        âŠ¢0
        (~-var âŠ¢0) }}}}}

mutual
  -- Valid contexts are well-formed
  soundContext : âŠ©áµ› Î“ â†’ âŠ¢ Î“
  soundContext Îµ = Îµ
  soundContext (x âˆ™ xâ‚) =
    soundContext x âˆ™ escape (irrelevanceâ€² (subst-id _)
                                             (projâ‚ (unwrap xâ‚ (soundContext x)
                                                        (idSubstS x))))

  -- From a valid context we can constuct a valid identity substitution
  idSubstS : ([Î“] : âŠ©áµ› Î“) â†’ Î“ âŠ©Ë¢ idSubst âˆ· Î“ / [Î“] / soundContext [Î“]
  idSubstS Îµ = lift tt
  idSubstS {Î“ = Î“ âˆ™ A} ([Î“] âˆ™ [A]) =
    let âŠ¢Î“ = soundContext [Î“]
        âŠ¢Î“âˆ™A = soundContext ([Î“] âˆ™ [A])
        âŠ¢Î“âˆ™Aâ€² = âŠ¢Î“ âˆ™ escape (projâ‚ (unwrap [A] âŠ¢Î“ (idSubstS [Î“])))
        [A]â€² = wk1SubstS {F = A [ idSubst ]} [Î“] âŠ¢Î“
                         (escape (projâ‚ (unwrap [A] (soundContext [Î“])
                                                (idSubstS [Î“]))))
                         (idSubstS [Î“])
        [tailÏƒ] = irrelevanceSubstâ€² (PE.cong (_âˆ™_ Î“) (subst-id A))
                                    [Î“] [Î“] âŠ¢Î“âˆ™Aâ€² âŠ¢Î“âˆ™A [A]â€²
        var0 = var âŠ¢Î“âˆ™A (PE.subst (Î» x â†’ x0 âˆ· x âˆˆ Î“ âˆ™ A)
                                  (wk-subst A)
                                  (PE.subst (Î» x â†’ x0 âˆ· wk1 (A [ idSubst ])
                                                     âˆˆ Î“ âˆ™ x)
                                            (subst-id A) here))
    in  [tailÏƒ]
    ,   neuTerm (projâ‚ (unwrap [A] âŠ¢Î“âˆ™A [tailÏƒ]))
                (var x0)
                var0 (~-var var0)

-- Reflexivity valid substitutions
reflSubst : âˆ€ {Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
            ([Ïƒ] : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î”)
          â†’ Î” âŠ©Ë¢ Ïƒ â‰¡ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ]
reflSubst Îµ âŠ¢Î” [Ïƒ] = lift tt
reflSubst ([Î“] âˆ™ x) âŠ¢Î” [Ïƒ] =
  reflSubst [Î“] âŠ¢Î” (projâ‚ [Ïƒ]) , reflEqTerm (projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))) (projâ‚‚ [Ïƒ])

-- Reflexivity of valid identity substitution
reflIdSubst : ([Î“] : âŠ©áµ› Î“)
            â†’ Î“ âŠ©Ë¢ idSubst â‰¡ idSubst âˆ· Î“ / [Î“] / soundContext [Î“] / idSubstS [Î“]
reflIdSubst [Î“] = reflSubst [Î“] (soundContext [Î“]) (idSubstS [Î“])

-- Symmetry of valid substitution
symS : âˆ€ {Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
       ([Ïƒ]  : Î” âŠ©Ë¢ Ïƒ  âˆ· Î“ / [Î“] / âŠ¢Î”)
       ([Ïƒâ€²] : Î” âŠ©Ë¢ Ïƒâ€² âˆ· Î“ / [Î“] / âŠ¢Î”)
     â†’ Î” âŠ©Ë¢ Ïƒ â‰¡ Ïƒâ€² âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ]
     â†’ Î” âŠ©Ë¢ Ïƒâ€² â‰¡ Ïƒ âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒâ€²]
symS Îµ âŠ¢Î” [Ïƒ] [Ïƒâ€²] [Ïƒâ‰¡Ïƒâ€²] = lift tt
symS ([Î“] âˆ™ x) âŠ¢Î” [Ïƒ] [Ïƒâ€²] [Ïƒâ‰¡Ïƒâ€²] =
  symS [Î“] âŠ¢Î” (projâ‚ [Ïƒ]) (projâ‚ [Ïƒâ€²]) (projâ‚ [Ïƒâ‰¡Ïƒâ€²])
  , let [ÏƒA]           = projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))
        [Ïƒâ€²A]          = projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒâ€²]))
        [ÏƒAâ‰¡Ïƒâ€²A]       = (projâ‚‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))) (projâ‚ [Ïƒâ€²]) (projâ‚ [Ïƒâ‰¡Ïƒâ€²])
        [headÏƒâ€²â‰¡headÏƒ] = symEqTerm [ÏƒA] (projâ‚‚ [Ïƒâ‰¡Ïƒâ€²])
    in  convEqTermâ‚ [ÏƒA] [Ïƒâ€²A] [ÏƒAâ‰¡Ïƒâ€²A] [headÏƒâ€²â‰¡headÏƒ]

opaque

  -- Symmetry for _âŠ©áµ›âŸ¨_âŸ©_â‰¡_/_/_.

  sym-âŠ©áµ›â‰¡// :
    (âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“)
    (âŠ©B : Î“ âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“) â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© A â‰¡ B / âŠ©Î“ / âŠ©A â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© B â‰¡ A / âŠ©Î“ / âŠ©B
  sym-âŠ©áµ›â‰¡// âŠ©A âŠ©B Aâ‰¡B _ âŠ©Ïƒ =
    symEq (âŠ©A .unwrap _ _ .projâ‚) (âŠ©B .unwrap _ _ .projâ‚) (Aâ‰¡B _ âŠ©Ïƒ)

opaque

  -- Symmetry for _âŠ©áµ›âŸ¨_âŸ©_â‰¡_âˆ·_/_/_.

  sym-âŠ©áµ›â‰¡âˆ·// :
    âˆ€ t u â†’
    (âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“) â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© t â‰¡ u âˆ· A / âŠ©Î“ / âŠ©A â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© u â‰¡ t âˆ· A / âŠ©Î“ / âŠ©A
  sym-âŠ©áµ›â‰¡âˆ·// _ _ âŠ©A tâ‰¡u _ âŠ©Ïƒ =
    symEqTerm (âŠ©A .unwrap _ _ .projâ‚) (tâ‰¡u _ âŠ©Ïƒ)

-- Transitivity of valid substitution
transS : âˆ€ {Ïƒâ€³ Î“ Î”} ([Î“] : âŠ©áµ› Î“) (âŠ¢Î” : âŠ¢ Î”)
         ([Ïƒ]   : Î” âŠ©Ë¢ Ïƒ   âˆ· Î“ / [Î“] / âŠ¢Î”)
         ([Ïƒâ€²]  : Î” âŠ©Ë¢ Ïƒâ€²  âˆ· Î“ / [Î“] / âŠ¢Î”)
         ([Ïƒâ€³] : Î” âŠ©Ë¢ Ïƒâ€³ âˆ· Î“ / [Î“] / âŠ¢Î”)
       â†’ Î” âŠ©Ë¢ Ïƒ  â‰¡ Ïƒâ€²  âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ]
       â†’ Î” âŠ©Ë¢ Ïƒâ€² â‰¡ Ïƒâ€³ âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒâ€²]
       â†’ Î” âŠ©Ë¢ Ïƒ  â‰¡ Ïƒâ€³ âˆ· Î“ / [Î“] / âŠ¢Î” / [Ïƒ]
transS Îµ âŠ¢Î” [Ïƒ] [Ïƒâ€²] [Ïƒâ€³] [Ïƒâ‰¡Ïƒâ€²] [Ïƒâ€²â‰¡Ïƒâ€³] = lift tt
transS ([Î“] âˆ™ x) âŠ¢Î” [Ïƒ] [Ïƒâ€²] [Ïƒâ€³] [Ïƒâ‰¡Ïƒâ€²] [Ïƒâ€²â‰¡Ïƒâ€³] =
  transS [Î“] âŠ¢Î” (projâ‚ [Ïƒ]) (projâ‚ [Ïƒâ€²]) (projâ‚ [Ïƒâ€³])
         (projâ‚ [Ïƒâ‰¡Ïƒâ€²]) (projâ‚ [Ïƒâ€²â‰¡Ïƒâ€³])
  , let [ÏƒA]   = projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))
        [Ïƒâ€²A]  = projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒâ€²]))
        [Ïƒâ€³A] = projâ‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒâ€³]))
        [Ïƒâ€²â‰¡Ïƒâ€³]â€² = convEqTermâ‚‚ [ÏƒA] [Ïƒâ€²A]
                                ((projâ‚‚ (unwrap x âŠ¢Î” (projâ‚ [Ïƒ]))) (projâ‚ [Ïƒâ€²])
                                        (projâ‚ [Ïƒâ‰¡Ïƒâ€²])) (projâ‚‚ [Ïƒâ€²â‰¡Ïƒâ€³])
    in  transEqTerm [ÏƒA] (projâ‚‚ [Ïƒâ‰¡Ïƒâ€²]) [Ïƒâ€²â‰¡Ïƒâ€³]â€²

opaque

  -- Transitivity for _âŠ©áµ›âŸ¨_âŸ©_â‰¡_/_/_.

  trans-âŠ©áµ›â‰¡// :
    (âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“)
    (âŠ©B : Î“ âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“) â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© C / âŠ©Î“ â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© A â‰¡ B / âŠ©Î“ / âŠ©A â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© B â‰¡ C / âŠ©Î“ / âŠ©B â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© A â‰¡ C / âŠ©Î“ / âŠ©A
  trans-âŠ©áµ›â‰¡// âŠ©A âŠ©B âŠ©C Aâ‰¡B Bâ‰¡C _ âŠ©Ïƒ =
    transEq (âŠ©A .unwrap _ _ .projâ‚) (âŠ©B .unwrap _ _ .projâ‚)
      (âŠ©C .unwrap _ âŠ©Ïƒ .projâ‚) (Aâ‰¡B _ âŠ©Ïƒ) (Bâ‰¡C _ âŠ©Ïƒ)

opaque

  -- Transitivity for _âŠ©áµ›âŸ¨_âŸ©_â‰¡_âˆ·_/_/_.

  trans-âŠ©áµ›â‰¡âˆ·// :
    âˆ€ t u v â†’
    (âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“) â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© t â‰¡ u âˆ· A / âŠ©Î“ / âŠ©A â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© u â‰¡ v âˆ· A / âŠ©Î“ / âŠ©A â†’
    Î“ âŠ©áµ›âŸ¨ l âŸ© t â‰¡ v âˆ· A / âŠ©Î“ / âŠ©A
  trans-âŠ©áµ›â‰¡âˆ·// _ _ _ âŠ©A tâ‰¡u uâ‰¡v _ âŠ©Ïƒ =
    transEqTerm (âŠ©A .unwrap _ _ .projâ‚) (tâ‰¡u _ âŠ©Ïƒ) (uâ‰¡v _ âŠ©Ïƒ)

opaque

  -- A validity lemma for sgSubst.

  sgSubstS :
    (âŠ©áµ›A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“)
    (âŠ©A : Î“ âŠ©âŸ¨ l âŸ© A) â†’
    Î“ âŠ©âŸ¨ l âŸ© t âˆ· A / âŠ©A â†’
    Î“ âŠ©Ë¢ sgSubst t âˆ· Î“ âˆ™ A / âŠ©Î“ âˆ™ âŠ©áµ›A / soundContext âŠ©Î“
  sgSubstS âŠ©áµ›A âŠ©A âŠ©t =
      idSubstS _
    , irrelevanceTermâ€² (PE.sym (subst-id _))
        âŠ©A (âŠ©áµ›A .unwrap _ _ .projâ‚) âŠ©t

opaque
  unfolding sgSubstS

  -- An equality preservation lemma for sgSubst.

  sgSubstSEq :
    {âŠ©áµ›A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©A : Î“ âŠ©âŸ¨ l âŸ© A}
    {âŠ©t : Î“ âŠ©âŸ¨ l âŸ© t âˆ· A / âŠ©A} â†’
    Î“ âŠ©âŸ¨ l âŸ© t â‰¡ u âˆ· A / âŠ©A â†’
    Î“ âŠ©Ë¢ sgSubst t â‰¡ sgSubst u âˆ· Î“ âˆ™ A /
      âŠ©Î“ âˆ™ âŠ©áµ›A / soundContext âŠ©Î“ / sgSubstS âŠ©áµ›A âŠ©A âŠ©t
  sgSubstSEq {âŠ©áµ›A = âŠ©áµ›A} {âŠ©A = âŠ©A} tâ‰¡u =
      reflIdSubst _
    , irrelevanceEqTermâ€² (PE.sym (subst-id _))
        âŠ©A (âŠ©áµ›A .unwrap _ _ .projâ‚) tâ‰¡u

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’âŠ©[â‡‘]â‰¡[â‡‘] :
    {Ïƒâ‚ Ïƒâ‚‚ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©Ïƒâ‚ : Î” âŠ©Ë¢ Ïƒâ‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    (âŠ©B : Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A) â†’
    Î” âŠ©Ë¢ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” â†’
    Î” âŠ©Ë¢ Ïƒâ‚ â‰¡ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” / âŠ©Ïƒâ‚ â†’
    Î” âˆ™ A [ Ïƒâ‚ ] âŠ©âŸ¨ l âŸ© B [ liftSubst Ïƒâ‚ ] â‰¡ B [ liftSubst Ïƒâ‚‚ ] /
      âŠ©B .unwrap _ (liftSubstS _ _ âŠ©A âŠ©Ïƒâ‚) .projâ‚
  âŠ©áµ›â†’â‰¡â†’âŠ©[â‡‘]â‰¡[â‡‘] {âŠ©A} {âŠ©Ïƒâ‚} âŠ©B âŠ©Ïƒâ‚‚ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ =
    âŠ©B .unwrap _ (liftSubstS _ _ âŠ©A âŠ©Ïƒâ‚) .projâ‚‚
      (liftSubstSâ€² âŠ©A âŠ©Ïƒâ‚‚ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚)
      (liftSubstSEq _ _ âŠ©A _ âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚)

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ :
    {Ïƒâ‚ Ïƒâ‚‚ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©Ïƒâ‚ : Î” âŠ©Ë¢ Ïƒâ‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”}
    {âŠ©Ïƒâ‚‚ : Î” âŠ©Ë¢ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A â†’
    (âŠ©B[â‡‘Ïƒâ‚][tâ‚] : Î” âŠ©âŸ¨ l âŸ© B [ liftSubst Ïƒâ‚ ] [ tâ‚ ]â‚€) â†’
    Î” âŠ©Ë¢ Ïƒâ‚ â‰¡ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” / âŠ©Ïƒâ‚ â†’
    let âŠ©Aâ‚ , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒâ‚
        âŠ©Aâ‚‚ , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒâ‚‚
    in
    Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· A [ Ïƒâ‚ ] / âŠ©Aâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· A [ Ïƒâ‚‚ ] / âŠ©Aâ‚‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· A [ Ïƒâ‚ ] / âŠ©Aâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ© B [ liftSubst Ïƒâ‚ ] [ tâ‚ ]â‚€ â‰¡ B [ liftSubst Ïƒâ‚‚ ] [ tâ‚‚ ]â‚€
      / âŠ©B[â‡‘Ïƒâ‚][tâ‚]
  âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘][]â‚€â‰¡[â‡‘][]â‚€
    {B} {âŠ©Ïƒâ‚} {âŠ©Ïƒâ‚‚} âŠ©B âŠ©B[â‡‘Ïƒâ‚][tâ‚] âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ âŠ©tâ‚ âŠ©tâ‚‚ âŠ©tâ‚â‰¡tâ‚‚ =
    irrelevanceEqâ€³
      (PE.sym (singleSubstComp _ _ B))
      (PE.sym (singleSubstComp _ _ B))
      (âŠ©B .unwrap _ (âŠ©Ïƒâ‚ , âŠ©tâ‚) .projâ‚)
      âŠ©B[â‡‘Ïƒâ‚][tâ‚] $
    âŠ©B .unwrap _ (âŠ©Ïƒâ‚ , âŠ©tâ‚) .projâ‚‚ (âŠ©Ïƒâ‚‚ , âŠ©tâ‚‚) (âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ , âŠ©tâ‚â‰¡tâ‚‚)

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â‰¡â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ :
    {Ïƒ : Subst m n}
    {âŠ©Aâ‚ : Î“ âŠ©áµ›âŸ¨ l âŸ© Aâ‚ / âŠ©Î“}
    {âŠ©Aâ‚‚ : Î“ âŠ©áµ›âŸ¨ l âŸ© Aâ‚‚ / âŠ©Î“}
    (âŠ©Bâ‚ : Î“ âˆ™ Aâ‚ âŠ©áµ›âŸ¨ l âŸ© Bâ‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚) â†’
    Î“ âˆ™ Aâ‚‚ âŠ©áµ›âŸ¨ l âŸ© Bâ‚‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚‚ â†’
    Î“ âˆ™ Aâ‚ âŠ©áµ›âŸ¨ l âŸ© Bâ‚ â‰¡ Bâ‚‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚ / âŠ©Bâ‚ â†’
    (âŠ©Bâ‚[â‡‘Ïƒ][tâ‚] : Î” âŠ©âŸ¨ l âŸ© Bâ‚ [ liftSubst Ïƒ ] [ tâ‚ ]â‚€)
    (âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”) â†’
    let âŠ©Aâ‚ , _ = âŠ©Aâ‚ .unwrap âŠ¢Î” âŠ©Ïƒ
        âŠ©Aâ‚‚ , _ = âŠ©Aâ‚‚ .unwrap âŠ¢Î” âŠ©Ïƒ
    in
    Î” âŠ©âŸ¨ l âŸ© Aâ‚ [ Ïƒ ] â‰¡ Aâ‚‚ [ Ïƒ ] / âŠ©Aâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· Aâ‚ [ Ïƒ ] / âŠ©Aâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· Aâ‚‚ [ Ïƒ ] / âŠ©Aâ‚‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· Aâ‚ [ Ïƒ ] / âŠ©Aâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ©
      Bâ‚ [ liftSubst Ïƒ ] [ tâ‚ ]â‚€ â‰¡ Bâ‚‚ [ liftSubst Ïƒ ] [ tâ‚‚ ]â‚€ /
      âŠ©Bâ‚[â‡‘Ïƒ][tâ‚]
  âŠ©áµ›â‰¡â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘][]â‚€â‰¡[â‡‘][]â‚€
    {Bâ‚} {Bâ‚‚} {âŠ©Aâ‚} {âŠ©Aâ‚‚}
    âŠ©Bâ‚ âŠ©Bâ‚‚ âŠ©Bâ‚â‰¡Bâ‚‚ âŠ©Bâ‚[â‡‘Ïƒ][tâ‚] âŠ©Ïƒ âŠ©Aâ‚â‰¡Aâ‚‚ âŠ©tâ‚ âŠ©tâ‚‚ âŠ©tâ‚â‰¡tâ‚‚ =
    let âŠ©Aâ‚ , _ = âŠ©Aâ‚ .unwrap _ âŠ©Ïƒ
        âŠ©Aâ‚‚ , _ = âŠ©Aâ‚‚ .unwrap _ âŠ©Ïƒ
    in
    case irrelevanceâ€² (PE.sym (singleSubstComp _ _ Bâ‚‚))
           (âŠ©Bâ‚‚ .unwrap _ (âŠ©Ïƒ , âŠ©tâ‚‚) .projâ‚) of Î» {
      âŠ©Bâ‚‚[â‡‘Ïƒ][tâ‚‚] â†’
    case convTermâ‚‚ âŠ©Aâ‚ âŠ©Aâ‚‚ âŠ©Aâ‚â‰¡Aâ‚‚ âŠ©tâ‚‚ of Î» {
      âŠ©tâ‚‚ â†’
    case irrelevanceâ€² (PE.sym (singleSubstComp _ _ Bâ‚))
           (âŠ©Bâ‚ .unwrap _ (âŠ©Ïƒ , âŠ©tâ‚‚) .projâ‚) of Î» {
      âŠ©Bâ‚[â‡‘Ïƒ][tâ‚‚] â†’
    transEq âŠ©Bâ‚[â‡‘Ïƒ][tâ‚] âŠ©Bâ‚[â‡‘Ïƒ][tâ‚‚] âŠ©Bâ‚‚[â‡‘Ïƒ][tâ‚‚]
      (âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘][]â‚€â‰¡[â‡‘][]â‚€
         âŠ©Bâ‚ âŠ©Bâ‚[â‡‘Ïƒ][tâ‚] (reflSubst _ _ âŠ©Ïƒ) âŠ©tâ‚ âŠ©tâ‚‚ âŠ©tâ‚â‰¡tâ‚‚)
      (irrelevanceEqâ€³
         (PE.sym (singleSubstComp _ _ Bâ‚))
         (PE.sym (singleSubstComp _ _ Bâ‚‚))
         (âŠ©Bâ‚ .unwrap _ (âŠ©Ïƒ , âŠ©tâ‚‚) .projâ‚)
         âŠ©Bâ‚[â‡‘Ïƒ][tâ‚‚]
         (âŠ©Bâ‚â‰¡Bâ‚‚ _ (âŠ©Ïƒ , âŠ©tâ‚‚))) }}}

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ¢[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ :
    {Ïƒâ‚ Ïƒâ‚‚ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©Ïƒâ‚ : Î” âŠ©Ë¢ Ïƒâ‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”}
    {âŠ©Ïƒâ‚‚ : Î” âŠ©Ë¢ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A â†’
    Î” âŠ©Ë¢ Ïƒâ‚ â‰¡ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” / âŠ©Ïƒâ‚ â†’
    let âŠ©Aâ‚ , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒâ‚
        âŠ©Aâ‚‚ , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒâ‚‚
    in
    Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· A [ Ïƒâ‚ ] / âŠ©Aâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· A [ Ïƒâ‚‚ ] / âŠ©Aâ‚‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· A [ Ïƒâ‚ ] / âŠ©Aâ‚ â†’
    Î” âŠ¢ B [ liftSubst Ïƒâ‚ ] [ tâ‚ ]â‚€ â‰¡ B [ liftSubst Ïƒâ‚‚ ] [ tâ‚‚ ]â‚€
  âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ¢[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ {B} {âŠ©Ïƒâ‚} âŠ©B âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ âŠ©tâ‚ âŠ©tâ‚‚ âŠ©tâ‚â‰¡tâ‚‚ =
    case irrelevanceâ€² (PE.sym (singleSubstComp _ _ B)) $
         âŠ©B .unwrap _ (âŠ©Ïƒâ‚ , âŠ©tâ‚) .projâ‚ of Î» {
      âŠ©B[â‡‘Ïƒâ‚][tâ‚] â†’
    â‰…-eq $ escapeEq âŠ©B[â‡‘Ïƒâ‚][tâ‚] $
    âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ âŠ©B âŠ©B[â‡‘Ïƒâ‚][tâ‚] âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ âŠ©tâ‚ âŠ©tâ‚‚ âŠ©tâ‚â‰¡tâ‚‚ }

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â‰¡â†’â‰¡â†’â‰¡â†’âŠ¢[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ :
    {Ïƒ : Subst m n}
    {âŠ©Aâ‚ : Î“ âŠ©áµ›âŸ¨ l âŸ© Aâ‚ / âŠ©Î“}
    {âŠ©Aâ‚‚ : Î“ âŠ©áµ›âŸ¨ l âŸ© Aâ‚‚ / âŠ©Î“}
    (âŠ©Bâ‚ : Î“ âˆ™ Aâ‚ âŠ©áµ›âŸ¨ l âŸ© Bâ‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚) â†’
    Î“ âˆ™ Aâ‚‚ âŠ©áµ›âŸ¨ l âŸ© Bâ‚‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚‚ â†’
    Î“ âˆ™ Aâ‚ âŠ©áµ›âŸ¨ l âŸ© Bâ‚ â‰¡ Bâ‚‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚ / âŠ©Bâ‚ â†’
    (âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”) â†’
    let âŠ©Aâ‚ , _ = âŠ©Aâ‚ .unwrap âŠ¢Î” âŠ©Ïƒ
        âŠ©Aâ‚‚ , _ = âŠ©Aâ‚‚ .unwrap âŠ¢Î” âŠ©Ïƒ
    in
    Î” âŠ©âŸ¨ l âŸ© Aâ‚ [ Ïƒ ] â‰¡ Aâ‚‚ [ Ïƒ ] / âŠ©Aâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· Aâ‚ [ Ïƒ ] / âŠ©Aâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· Aâ‚‚ [ Ïƒ ] / âŠ©Aâ‚‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· Aâ‚ [ Ïƒ ] / âŠ©Aâ‚ â†’
    Î” âŠ¢ Bâ‚ [ liftSubst Ïƒ ] [ tâ‚ ]â‚€ â‰¡ Bâ‚‚ [ liftSubst Ïƒ ] [ tâ‚‚ ]â‚€
  âŠ©áµ›â‰¡â†’â‰¡â†’â‰¡â†’âŠ¢[â‡‘][]â‚€â‰¡[â‡‘][]â‚€
    {Bâ‚} {Bâ‚‚} {âŠ©Aâ‚} {âŠ©Aâ‚‚}
    âŠ©Bâ‚ âŠ©Bâ‚‚ âŠ©Bâ‚â‰¡Bâ‚‚ âŠ©Ïƒ âŠ©Aâ‚â‰¡Aâ‚‚ âŠ©tâ‚ âŠ©tâ‚‚ âŠ©tâ‚â‰¡tâ‚‚ =
    case irrelevanceâ€² (PE.sym (singleSubstComp _ _ Bâ‚)) $
         âŠ©Bâ‚ .unwrap _ (âŠ©Ïƒ , âŠ©tâ‚) .projâ‚ of Î» {
      âŠ©Bâ‚[â‡‘Ïƒ][tâ‚] â†’
    â‰…-eq $ escapeEq âŠ©Bâ‚[â‡‘Ïƒ][tâ‚] $
    âŠ©áµ›â‰¡â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘][]â‚€â‰¡[â‡‘][]â‚€
      âŠ©Bâ‚ âŠ©Bâ‚‚ âŠ©Bâ‚â‰¡Bâ‚‚ âŠ©Bâ‚[â‡‘Ïƒ][tâ‚] âŠ©Ïƒ âŠ©Aâ‚â‰¡Aâ‚‚ âŠ©tâ‚ âŠ©tâ‚‚ âŠ©tâ‚â‰¡tâ‚‚ }

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’âŠ¢[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ :
    {Ïƒ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A â†’
    let âŠ©A , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒ in
    Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· A [ Ïƒ ] / âŠ©A â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· A [ Ïƒ ] / âŠ©A â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· A [ Ïƒ ] / âŠ©A â†’
    Î” âŠ¢ B [ liftSubst Ïƒ ] [ tâ‚ ]â‚€ â‰¡ B [ liftSubst Ïƒ ] [ tâ‚‚ ]â‚€
  âŠ©áµ›â†’â‰¡â†’âŠ¢[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ {âŠ©Ïƒ} âŠ©B =
    âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ¢[â‡‘][]â‚€â‰¡[â‡‘][]â‚€ âŠ©B (reflSubst _ _ âŠ©Ïƒ)

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’â‰¡â†’â‰¡â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] :
    {Ïƒ : Subst m n} â†’
    let â‡‘â‡‘Ïƒ = liftSubstn Ïƒ 2 in
    {âŠ©Aâ‚ : Î“ âŠ©áµ›âŸ¨ l âŸ© Aâ‚ / âŠ©Î“}
    {âŠ©Aâ‚‚ : Î“ âŠ©áµ›âŸ¨ l âŸ© Aâ‚‚ / âŠ©Î“}
    {âŠ©Bâ‚ : Î“ âˆ™ Aâ‚ âŠ©áµ›âŸ¨ l âŸ© Bâ‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚}
    {âŠ©Bâ‚‚ : Î“ âˆ™ Aâ‚‚ âŠ©áµ›âŸ¨ l âŸ© Bâ‚‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚‚}
    {âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    let âŠ©Aâ‚[Ïƒ] , _ = âŠ©Aâ‚ .unwrap âŠ¢Î” âŠ©Ïƒ
        âŠ©Aâ‚‚[Ïƒ] , _ = âŠ©Aâ‚‚ .unwrap âŠ¢Î” âŠ©Ïƒ
    in
    {âŠ©tâ‚ : Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· Aâ‚ [ Ïƒ ] / âŠ©Aâ‚[Ïƒ]}
    {âŠ©tâ‚‚ : Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· Aâ‚‚ [ Ïƒ ] / âŠ©Aâ‚‚[Ïƒ]}
    (âŠ©Aâ‚[Ïƒ]â‰¡Aâ‚‚[Ïƒ] : Î” âŠ©âŸ¨ l âŸ© Aâ‚ [ Ïƒ ] â‰¡ Aâ‚‚ [ Ïƒ ] / âŠ©Aâ‚[Ïƒ]) â†’
    let âŠ©Bâ‚[Ïƒ,tâ‚] , _ = âŠ©Bâ‚ .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©tâ‚)
        âŠ©Bâ‚‚[Ïƒ,tâ‚‚] , _ = âŠ©Bâ‚‚ .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©tâ‚‚)
        âŠ©Bâ‚[Ïƒ,tâ‚‚] , _ = âŠ©Bâ‚ .unwrap âŠ¢Î”
          (âŠ©Ïƒ , convTermâ‚‚ âŠ©Aâ‚[Ïƒ] âŠ©Aâ‚‚[Ïƒ] âŠ©Aâ‚[Ïƒ]â‰¡Aâ‚‚[Ïƒ] âŠ©tâ‚‚)
    in
    Î” âŠ©âŸ¨ l âŸ© Bâ‚ [ consSubst Ïƒ tâ‚‚ ] â‰¡ Bâ‚‚ [ consSubst Ïƒ tâ‚‚ ] / âŠ©Bâ‚[Ïƒ,tâ‚‚] â†’
    (âŠ©Câ‚ : Î“ âˆ™ Aâ‚ âˆ™ Bâ‚ âŠ©áµ›âŸ¨ l âŸ© Câ‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚ âˆ™ âŠ©Bâ‚) â†’
    Î“ âˆ™ Aâ‚‚ âˆ™ Bâ‚‚ âŠ©áµ›âŸ¨ l âŸ© Câ‚‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚‚ âˆ™ âŠ©Bâ‚‚ â†’
    Î“ âˆ™ Aâ‚ âˆ™ Bâ‚ âŠ©áµ›âŸ¨ l âŸ© Câ‚ â‰¡ Câ‚‚ / âŠ©Î“ âˆ™ âŠ©Aâ‚ âˆ™ âŠ©Bâ‚ / âŠ©Câ‚ â†’
    (âŠ©Câ‚[â‡‘â‡‘Ïƒ][tâ‚,uâ‚] : Î” âŠ©âŸ¨ l âŸ© Câ‚ [ â‡‘â‡‘Ïƒ ] [ tâ‚ , uâ‚ ]â‚â‚€) â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· Aâ‚ [ Ïƒ ] / âŠ©Aâ‚[Ïƒ] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ âˆ· Bâ‚ [ consSubst Ïƒ tâ‚ ] / âŠ©Bâ‚[Ïƒ,tâ‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚‚ âˆ· Bâ‚‚ [ consSubst Ïƒ tâ‚‚ ] / âŠ©Bâ‚‚[Ïƒ,tâ‚‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ â‰¡ uâ‚‚ âˆ· Bâ‚ [ consSubst Ïƒ tâ‚ ] / âŠ©Bâ‚[Ïƒ,tâ‚] â†’
    Î” âŠ©âŸ¨ l âŸ© Câ‚ [ â‡‘â‡‘Ïƒ ] [ tâ‚ , uâ‚ ]â‚â‚€ â‰¡ Câ‚‚ [ â‡‘â‡‘Ïƒ ] [ tâ‚‚ , uâ‚‚ ]â‚â‚€ /
      âŠ©Câ‚[â‡‘â‡‘Ïƒ][tâ‚,uâ‚]
  âŠ©áµ›â†’â‰¡â†’â‰¡â†’â‰¡â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,]
    {Câ‚} {Câ‚‚} {âŠ©Aâ‚} {âŠ©Aâ‚‚} {âŠ©Bâ‚} {âŠ©Bâ‚‚} {âŠ©Ïƒ} {âŠ©tâ‚‚}
    âŠ©Aâ‚[Ïƒ]â‰¡Aâ‚‚[Ïƒ] âŠ©Bâ‚[Ïƒ,tâ‚]â‰¡Bâ‚‚[Ïƒ,tâ‚‚] âŠ©Câ‚ âŠ©Câ‚‚ âŠ©Câ‚â‰¡Câ‚‚ âŠ©Câ‚[â‡‘â‡‘Ïƒ][tâ‚,uâ‚]
    âŠ©tâ‚â‰¡tâ‚‚ âŠ©uâ‚ âŠ©uâ‚‚ âŠ©uâ‚â‰¡uâ‚‚ =
    irrelevanceEqâ€³
      (PE.sym (doubleSubstComp Câ‚ _ _ _))
      (PE.sym (doubleSubstComp Câ‚‚ _ _ _))
      (âŠ©Câ‚ .unwrap _ (_ , âŠ©uâ‚) .projâ‚)
      âŠ©Câ‚[â‡‘â‡‘Ïƒ][tâ‚,uâ‚] $
    case   ( âŠ©Ïƒ
           , convTermâ‚‚
               (âŠ©Aâ‚ .unwrap _ _ .projâ‚) (âŠ©Aâ‚‚ .unwrap _ _ .projâ‚)
               âŠ©Aâ‚[Ïƒ]â‰¡Aâ‚‚[Ïƒ] âŠ©tâ‚‚
           )
         , convTermâ‚‚
             (âŠ©Bâ‚ .unwrap _ _ .projâ‚) (âŠ©Bâ‚‚ .unwrap _ _ .projâ‚)
             âŠ©Bâ‚[Ïƒ,tâ‚]â‰¡Bâ‚‚[Ïƒ,tâ‚‚] âŠ©uâ‚‚ of Î» {
      âŠ©Ïƒ,tâ‚‚,uâ‚‚ â†’
    transEq
      (âŠ©Câ‚ .unwrap _ _ .projâ‚)
      (âŠ©Câ‚ .unwrap {Ïƒ = consSubst (consSubst _ _) _} _ âŠ©Ïƒ,tâ‚‚,uâ‚‚ .projâ‚)
      (âŠ©Câ‚‚ .unwrap _ ((âŠ©Ïƒ , âŠ©tâ‚‚) , âŠ©uâ‚‚) .projâ‚)
      (âŠ©Câ‚ .unwrap _ _ .projâ‚‚
         âŠ©Ïƒ,tâ‚‚,uâ‚‚ ((reflSubst _ _ âŠ©Ïƒ , âŠ©tâ‚â‰¡tâ‚‚) , âŠ©uâ‚â‰¡uâ‚‚))
      (âŠ©Câ‚â‰¡Câ‚‚ _ _) }

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] :
    {Ïƒâ‚ Ïƒâ‚‚ : Subst m n} â†’
    let â‡‘â‡‘Ïƒâ‚ = liftSubstn Ïƒâ‚ 2
        â‡‘â‡‘Ïƒâ‚‚ = liftSubstn Ïƒâ‚‚ 2
    in
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©B : Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A}
    {âŠ©Ïƒâ‚ : Î” âŠ©Ë¢ Ïƒâ‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”}
    {âŠ©Ïƒâ‚‚ : Î” âŠ©Ë¢ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    let âŠ©A[Ïƒâ‚] , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒâ‚
        âŠ©A[Ïƒâ‚‚] , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒâ‚‚
    in
    {âŠ©tâ‚ : Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· A [ Ïƒâ‚ ] / âŠ©A[Ïƒâ‚]}
    {âŠ©tâ‚‚ : Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· A [ Ïƒâ‚‚ ] / âŠ©A[Ïƒâ‚‚]} â†’
    let âŠ©B[Ïƒâ‚,tâ‚] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒâ‚ , âŠ©tâ‚)
        âŠ©B[Ïƒâ‚‚,tâ‚‚] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒâ‚‚ , âŠ©tâ‚‚)
    in
    Î“ âˆ™ A âˆ™ B âŠ©áµ›âŸ¨ l âŸ© C / âŠ©Î“ âˆ™ âŠ©A âˆ™ âŠ©B â†’
    (âŠ©C[â‡‘â‡‘Ïƒâ‚][tâ‚,uâ‚] : Î” âŠ©âŸ¨ l âŸ© C [ â‡‘â‡‘Ïƒâ‚ ] [ tâ‚ , uâ‚ ]â‚â‚€) â†’
    Î” âŠ©Ë¢ Ïƒâ‚ â‰¡ Ïƒâ‚‚ âˆ· Î“ / âŠ©Î“ / âŠ¢Î” / âŠ©Ïƒâ‚ â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· A [ Ïƒâ‚ ] / âŠ©A[Ïƒâ‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ âˆ· B [ consSubst Ïƒâ‚ tâ‚ ] / âŠ©B[Ïƒâ‚,tâ‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚‚ âˆ· B [ consSubst Ïƒâ‚‚ tâ‚‚ ] / âŠ©B[Ïƒâ‚‚,tâ‚‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ â‰¡ uâ‚‚ âˆ· B [ consSubst Ïƒâ‚ tâ‚ ] / âŠ©B[Ïƒâ‚,tâ‚] â†’
    Î” âŠ©âŸ¨ l âŸ© C [ â‡‘â‡‘Ïƒâ‚ ] [ tâ‚ , uâ‚ ]â‚â‚€ â‰¡ C [ â‡‘â‡‘Ïƒâ‚‚ ] [ tâ‚‚ , uâ‚‚ ]â‚â‚€ /
      âŠ©C[â‡‘â‡‘Ïƒâ‚][tâ‚,uâ‚]
  âŠ©áµ›â†’â‰¡â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,]
    {C} âŠ©C âŠ©C[â‡‘â‡‘Ïƒâ‚][tâ‚,uâ‚] âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ âŠ©tâ‚â‰¡tâ‚‚ âŠ©uâ‚ âŠ©uâ‚‚ âŠ©uâ‚â‰¡uâ‚‚ =
    irrelevanceEqâ€³
      (PE.sym (doubleSubstComp C _ _ _))
      (PE.sym (doubleSubstComp C _ _ _))
      (âŠ©C .unwrap _ (_ , âŠ©uâ‚) .projâ‚)
      âŠ©C[â‡‘â‡‘Ïƒâ‚][tâ‚,uâ‚] $
    âŠ©C .unwrap _ (_ , âŠ©uâ‚) .projâ‚‚ (_ , âŠ©uâ‚‚)
      ((âŠ©Ïƒâ‚â‰¡Ïƒâ‚‚ , âŠ©tâ‚â‰¡tâ‚‚) , âŠ©uâ‚â‰¡uâ‚‚)

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] :
    {Ïƒ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©B : Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A}
    {âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    let âŠ©A[Ïƒ] , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒ in
    {âŠ©tâ‚ : Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ]}
    {âŠ©tâ‚‚ : Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ]} â†’
    let âŠ©B[Ïƒ,tâ‚] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©tâ‚)
        âŠ©B[Ïƒ,tâ‚‚] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©tâ‚‚)
    in
    Î“ âˆ™ A âˆ™ B âŠ©áµ›âŸ¨ l âŸ© C / âŠ©Î“ âˆ™ âŠ©A âˆ™ âŠ©B â†’
    let â‡‘â‡‘Ïƒ = liftSubstn Ïƒ 2 in
    (âŠ©C[â‡‘â‡‘Ïƒ][tâ‚,uâ‚] : Î” âŠ©âŸ¨ l âŸ© C [ â‡‘â‡‘Ïƒ ] [ tâ‚ , uâ‚ ]â‚â‚€) â†’
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ âˆ· B [ consSubst Ïƒ tâ‚ ] / âŠ©B[Ïƒ,tâ‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚‚ âˆ· B [ consSubst Ïƒ tâ‚‚ ] / âŠ©B[Ïƒ,tâ‚‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ â‰¡ uâ‚‚ âˆ· B [ consSubst Ïƒ tâ‚ ] / âŠ©B[Ïƒ,tâ‚] â†’
    Î” âŠ©âŸ¨ l âŸ© C [ â‡‘â‡‘Ïƒ ] [ tâ‚ , uâ‚ ]â‚â‚€ â‰¡ C [ â‡‘â‡‘Ïƒ ] [ tâ‚‚ , uâ‚‚ ]â‚â‚€ /
      âŠ©C[â‡‘â‡‘Ïƒ][tâ‚,uâ‚]
  âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] {âŠ©Ïƒ} âŠ©C âŠ©C[â‡‘â‡‘Ïƒ][tâ‚,uâ‚] =
    âŠ©áµ›â†’â‰¡â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] âŠ©C âŠ©C[â‡‘â‡‘Ïƒ][tâ‚,uâ‚] (reflSubst _ _ âŠ©Ïƒ)

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ¢[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] :
    {Ïƒ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©B : Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A}
    {âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    let âŠ©A[Ïƒ] , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒ in
    {âŠ©tâ‚ : Î” âŠ©âŸ¨ l âŸ© tâ‚ âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ]}
    {âŠ©tâ‚‚ : Î” âŠ©âŸ¨ l âŸ© tâ‚‚ âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ]} â†’
    let âŠ©B[Ïƒ,tâ‚] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©tâ‚)
        âŠ©B[Ïƒ,tâ‚‚] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©tâ‚‚)
    in
    Î“ âˆ™ A âˆ™ B âŠ©áµ›âŸ¨ l âŸ© C / âŠ©Î“ âˆ™ âŠ©A âˆ™ âŠ©B â†’
    let â‡‘â‡‘Ïƒ = liftSubstn Ïƒ 2 in
    Î” âŠ©âŸ¨ l âŸ© tâ‚ â‰¡ tâ‚‚ âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ âˆ· B [ consSubst Ïƒ tâ‚ ] / âŠ©B[Ïƒ,tâ‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚‚ âˆ· B [ consSubst Ïƒ tâ‚‚ ] / âŠ©B[Ïƒ,tâ‚‚] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ â‰¡ uâ‚‚ âˆ· B [ consSubst Ïƒ tâ‚ ] / âŠ©B[Ïƒ,tâ‚] â†’
    Î” âŠ¢ C [ â‡‘â‡‘Ïƒ ] [ tâ‚ , uâ‚ ]â‚â‚€ â‰¡ C [ â‡‘â‡‘Ïƒ ] [ tâ‚‚ , uâ‚‚ ]â‚â‚€
  âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ¢[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] {C} âŠ©C âŠ©tâ‚â‰¡tâ‚‚ âŠ©uâ‚ âŠ©uâ‚‚ âŠ©uâ‚â‰¡uâ‚‚ =
    case irrelevanceâ€² (PE.sym (doubleSubstComp C _ _ _)) $
         âŠ©C .unwrap _ (_ , âŠ©uâ‚) .projâ‚ of Î» {
      âŠ©C[â‡‘â‡‘Ïƒ][tâ‚,uâ‚] â†’
    â‰…-eq $ escapeEq âŠ©C[â‡‘â‡‘Ïƒ][tâ‚,uâ‚] $
    âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] âŠ©C âŠ©C[â‡‘â‡‘Ïƒ][tâ‚,uâ‚] âŠ©tâ‚â‰¡tâ‚‚ âŠ©uâ‚ âŠ©uâ‚‚ âŠ©uâ‚â‰¡uâ‚‚ }

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] :
    {Ïƒ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©B : Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A}
    {âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    let âŠ©A[Ïƒ] , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒ in
    {âŠ©t : Î” âŠ©âŸ¨ l âŸ© t âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ]} â†’
    let âŠ©B[Ïƒ,t] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©t) in
    Î“ âˆ™ A âˆ™ B âŠ©áµ›âŸ¨ l âŸ© C / âŠ©Î“ âˆ™ âŠ©A âˆ™ âŠ©B â†’
    let â‡‘â‡‘Ïƒ = liftSubstn Ïƒ 2 in
    (âŠ©C[â‡‘â‡‘Ïƒ][t,uâ‚] : Î” âŠ©âŸ¨ l âŸ© C [ â‡‘â‡‘Ïƒ ] [ t , uâ‚ ]â‚â‚€) â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ âˆ· B [ consSubst Ïƒ t ] / âŠ©B[Ïƒ,t] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚‚ âˆ· B [ consSubst Ïƒ t ] / âŠ©B[Ïƒ,t] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ â‰¡ uâ‚‚ âˆ· B [ consSubst Ïƒ t ] / âŠ©B[Ïƒ,t] â†’
    Î” âŠ©âŸ¨ l âŸ© C [ â‡‘â‡‘Ïƒ ] [ t , uâ‚ ]â‚â‚€ â‰¡ C [ â‡‘â‡‘Ïƒ ] [ t , uâ‚‚ ]â‚â‚€ /
      âŠ©C[â‡‘â‡‘Ïƒ][t,uâ‚]
  âŠ©áµ›â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] {âŠ©A} {âŠ©t} âŠ©C âŠ©C[â‡‘â‡‘Ïƒ][t,uâ‚] =
    âŠ©áµ›â†’â‰¡â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,]
      âŠ©C âŠ©C[â‡‘â‡‘Ïƒ][t,uâ‚] (reflEqTerm (âŠ©A .unwrap _ _ .projâ‚) âŠ©t)

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’â‰¡â†’âŠ¢[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] :
    {Ïƒ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©B : Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A}
    {âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    let âŠ©A[Ïƒ] , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒ in
    {âŠ©t : Î” âŠ©âŸ¨ l âŸ© t âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ]} â†’
    let âŠ©B[Ïƒ,t] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©t) in
    Î“ âˆ™ A âˆ™ B âŠ©áµ›âŸ¨ l âŸ© C / âŠ©Î“ âˆ™ âŠ©A âˆ™ âŠ©B â†’
    let â‡‘â‡‘Ïƒ = liftSubstn Ïƒ 2 in
    Î” âŠ©âŸ¨ l âŸ© uâ‚ âˆ· B [ consSubst Ïƒ t ] / âŠ©B[Ïƒ,t] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚‚ âˆ· B [ consSubst Ïƒ t ] / âŠ©B[Ïƒ,t] â†’
    Î” âŠ©âŸ¨ l âŸ© uâ‚ â‰¡ uâ‚‚ âˆ· B [ consSubst Ïƒ t ] / âŠ©B[Ïƒ,t] â†’
    Î” âŠ¢ C [ â‡‘â‡‘Ïƒ ] [ t , uâ‚ ]â‚â‚€ â‰¡ C [ â‡‘â‡‘Ïƒ ] [ t , uâ‚‚ ]â‚â‚€
  âŠ©áµ›â†’â‰¡â†’âŠ¢[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] {C} âŠ©C âŠ©uâ‚ âŠ©uâ‚‚ âŠ©uâ‚â‰¡uâ‚‚ =
    case irrelevanceâ€² (PE.sym (doubleSubstComp C _ _ _)) $
         âŠ©C .unwrap _ (_ , âŠ©uâ‚) .projâ‚ of Î» {
      âŠ©C[â‡‘â‡‘Ïƒ][t,uâ‚] â†’
    â‰…-eq $ escapeEq âŠ©C[â‡‘â‡‘Ïƒ][t,uâ‚] $
    âŠ©áµ›â†’â‰¡â†’âŠ©[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] âŠ©C âŠ©C[â‡‘â‡‘Ïƒ][t,uâ‚] âŠ©uâ‚ âŠ©uâ‚‚ âŠ©uâ‚â‰¡uâ‚‚ }

opaque

  -- An equality preservation lemma.

  âŠ©áµ›â†’âŠ¢[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] :
    {Ïƒ : Subst m n}
    {âŠ©A : Î“ âŠ©áµ›âŸ¨ l âŸ© A / âŠ©Î“}
    {âŠ©B : Î“ âˆ™ A âŠ©áµ›âŸ¨ l âŸ© B / âŠ©Î“ âˆ™ âŠ©A}
    {âŠ©Ïƒ : Î” âŠ©Ë¢ Ïƒ âˆ· Î“ / âŠ©Î“ / âŠ¢Î”} â†’
    let âŠ©A[Ïƒ] , _ = âŠ©A .unwrap âŠ¢Î” âŠ©Ïƒ in
    {âŠ©t : Î” âŠ©âŸ¨ l âŸ© t âˆ· A [ Ïƒ ] / âŠ©A[Ïƒ]} â†’
    let âŠ©B[Ïƒ,t] , _ = âŠ©B .unwrap âŠ¢Î” (âŠ©Ïƒ , âŠ©t) in
    Î“ âˆ™ A âˆ™ B âŠ©áµ›âŸ¨ l âŸ© C / âŠ©Î“ âˆ™ âŠ©A âˆ™ âŠ©B â†’
    let â‡‘â‡‘Ïƒ = liftSubstn Ïƒ 2 in
    Î” âŠ©âŸ¨ l âŸ© u âˆ· B [ consSubst Ïƒ t ] / âŠ©B[Ïƒ,t] â†’
    Î” âŠ¢ C [ â‡‘â‡‘Ïƒ ] [ t , u ]â‚â‚€ â‰¡ C [ â‡‘â‡‘Ïƒ ] [ t , u ]â‚â‚€
  âŠ©áµ›â†’âŠ¢[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,] {âŠ©B} {âŠ©t} âŠ©C âŠ©u =
    âŠ©áµ›â†’â‰¡â†’âŠ¢[â‡‘â‡‘][,]â‰¡[â‡‘â‡‘][,]
      âŠ©C âŠ©u âŠ©u (reflEqTerm (âŠ©B .unwrap _ (_ , âŠ©t) .projâ‚) âŠ©u)
