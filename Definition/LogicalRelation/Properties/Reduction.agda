------------------------------------------------------------------------
-- The logical relation is backwards-closed under reductions
------------------------------------------------------------------------

open import Definition.Typed.EqualityRelation
open import Definition.Typed.Restrictions
open import Graded.Modality

module Definition.LogicalRelation.Properties.Reduction
  {a} {M : Set a}
  {ùïÑ : Modality M}
  (R : Type-restrictions ùïÑ)
  {{eqrel : EqRelSet R}}
  where

open EqRelSet {{...}}
open Type-restrictions R

open import Definition.Untyped M hiding (Wk; K)
open import Definition.Untyped.Neutral M type-variant
open import Definition.Typed R
open import Definition.Typed.Properties R
-- The imported operator _,_ is not "supposed" to be used below, but
-- another operator with the same name is used, and if this import
-- statement is removed, then some code below fails to type-check (at
-- the time of writing).
open import Definition.Typed.Substitution R using (_,_)
import Definition.Typed.Weakening R as Wk
open import Definition.Typed.Well-formed R
open import Definition.LogicalRelation R
open import Definition.LogicalRelation.Irrelevance R
open import Definition.LogicalRelation.Properties.Kit R
open import Definition.LogicalRelation.Properties.Reflexivity R
open import Definition.LogicalRelation.Properties.Universe R
open import Definition.LogicalRelation.Properties.Transitivity R
open import Definition.LogicalRelation.Properties.Whnf R
open import Definition.LogicalRelation.Unary R

open import Tools.Function
open import Tools.Nat hiding (_<_)
open import Tools.Product
import Tools.PropositionalEquality as PE
open import Tools.Sum using (inj‚ÇÅ; inj‚ÇÇ)

private
  variable
    n       : Nat
    Œì       : Con Term n
    A B t u : Term n
    l       : Universe-level

-- Weak head expansion of reducible types.
redSubst* : ‚àÄ {A B : Term n} {l}
          ‚Üí Œì ‚ä¢ A ‚áí* B
          ‚Üí Œì ‚ä©‚ü® l ‚ü© B
          ‚Üí ‚àÉ Œª ([A] : Œì ‚ä©‚ü® l ‚ü© A)
          ‚Üí Œì ‚ä©‚ü® l ‚ü© A ‚â° B / [A]
redSubst* D (U·µ£‚Ä≤ l‚Ä≤ l< D‚Ä≤) =
  U·µ£‚Ä≤ l‚Ä≤ l< (D ‚á®* D‚Ä≤) , D‚Ä≤
redSubst* D (‚Ñï·µ£ D‚Ä≤) =
  ‚Ñï·µ£ (D ‚á®* D‚Ä≤) , D‚Ä≤
redSubst* D (Empty·µ£ D‚Ä≤) =
  Empty·µ£ (D ‚á®* D‚Ä≤) , D‚Ä≤
redSubst* D (Unit·µ£ (Unit‚Çú D‚Ä≤ ok)) =
  Unit·µ£ (Unit‚Çú (D ‚á®* D‚Ä≤) ok) , D‚Ä≤
redSubst* D (ne‚Ä≤ inc _ D‚Ä≤ neK K‚â°K) =
    ne‚Ä≤ inc _ (D ‚á®* D‚Ä≤) neK K‚â°K
  , ne‚Çå inc _ D‚Ä≤ neK K‚â°K
redSubst*
  D (B·µ£‚Ä≤ W F G D‚Ä≤ A‚â°A [F] [G] G-ext ok) =
    B·µ£‚Ä≤ W F G (D ‚á®* D‚Ä≤) A‚â°A [F] [G] G-ext ok
  , B‚Çå _ _ D‚Ä≤ A‚â°A (Œª œÅ ‚Üí reflEq ([F] œÅ)) (Œª œÅ [a] ‚Üí reflEq ([G] œÅ [a]))
redSubst* A‚áí*B (Id·µ£ ‚ä©B) =
    Id·µ£ record
      { ‚áí*Id  = A‚áí*B ‚á®* ‚áí*Id
      ; ‚ä©Ty   = ‚ä©Ty
      ; ‚ä©lhs  = ‚ä©lhs
      ; ‚ä©rhs  = ‚ä©rhs
      }
  , Id‚Çå‚Ä≤ ‚áí*Id (reflEq ‚ä©Ty) (reflEqTerm ‚ä©Ty ‚ä©lhs) (reflEqTerm ‚ä©Ty ‚ä©rhs)
  where
  open _‚ä©‚ÇóId_ ‚ä©B
redSubst* D (emb ‚â§·µò-refl x) with redSubst* D x
redSubst* D (emb ‚â§·µò-refl x) | y , y‚ÇÅ = emb ‚â§·µò-refl y , y‚ÇÅ
redSubst* A‚áí*B (emb (‚â§·µò-step p) ‚ä©B) =
  let ‚ä©A , A‚â°B = redSubst* A‚áí*B (emb p ‚ä©B) in
    emb-<-‚ä© ‚â§·µò-refl ‚ä©A
  , irrelevanceEq ‚ä©A (emb-<-‚ä© ‚â§·µò-refl ‚ä©A) A‚â°B

opaque

  -- Weak head expansion of reducible terms.
  redSubst*Term : ‚àÄ {A : Term n} {t u l}
                ‚Üí Œì ‚ä¢ t ‚áí* u ‚à∑ A
                ‚Üí ([A] : Œì ‚ä©‚ü® l ‚ü© A)
                ‚Üí Œì ‚ä©‚ü® l ‚ü© u ‚à∑ A / [A]
                ‚Üí Œì ‚ä©‚ü® l ‚ü© t ‚â° u ‚à∑ A / [A]
  redSubst*Term t‚áíu (U·µ£‚Ä≤ l ‚â§·µò-refl D) ‚ä©u =
    let U‚Çú A d typeA A‚â°A [u] = ‚ä©U‚à∑U‚áî‚ä©U‚â°‚à∑U .proj‚ÇÇ ‚ä©u
        A‚â°K = subset* D
        d‚Ä≤ = conv* t‚áíu A‚â°K ‚á®‚à∑* d
        q = redSubst* (univ* (conv* t‚áíu A‚â°K))
              (univEq (U·µ£‚Ä≤ l ‚â§·µò-refl (id (wf-‚ä¢‚â° (subset* D) .proj‚ÇÇ)))
                 (‚ä©U‚à∑U‚áî‚ä©U‚â°‚à∑U .proj‚ÇÅ (U‚Çú A d typeA A‚â°A [u])))
    in
    U‚Çú‚Çå A A d‚Ä≤ d typeA typeA A‚â°A (proj‚ÇÅ q) [u] (proj‚ÇÇ q)
  redSubst*Term t‚áíu ‚ä©U@(U·µ£‚Ä≤ l (‚â§·µò-step l<) D) ‚ä©u =
    let U‚Çú A D‚Ä≤ typeA A‚â°A [u] = ‚ä©U‚à∑U‚áî‚ä©U‚â°‚à∑U .proj‚ÇÇ ‚ä©u
        Un = U·µ£‚Ä≤ l l< D
        eq = redSubst*Term t‚áíu Un
               (‚ä©U‚à∑U‚áî‚ä©U‚â°‚à∑U .proj‚ÇÅ (U‚Çú A D‚Ä≤ typeA A‚â°A [u]))
    in
    irrelevanceEqTerm Un ‚ä©U eq
  redSubst*Term t‚áíu (‚Ñï·µ£ D) ‚ä©u =
    let ‚Ñï‚Çú n d n‚â°n prop = ‚ä©‚Ñï‚à∑‚Ñï‚áî‚ä©‚Ñï‚â°‚à∑‚Ñï .proj‚ÇÇ ‚ä©u
        t‚áíu‚Ä≤ = conv* t‚áíu (subset* D)
    in
    ‚Ñï‚Çú‚Çå n n (t‚áíu‚Ä≤ ‚á®‚à∑* d) d n‚â°n (Natural-prop‚áî[Natural]-prop .proj‚ÇÅ prop)
  redSubst*Term t‚áíu (Empty·µ£ D) ‚ä©u =
    let Empty‚Çú n d n‚â°n prop = ‚ä©Empty‚à∑Empty‚áî‚ä©Empty‚â°‚à∑Empty .proj‚ÇÇ ‚ä©u
        t‚áíu‚Ä≤ = conv* t‚áíu (subset* D)
    in
    Empty‚Çú‚Çå n n (t‚áíu‚Ä≤ ‚á®‚à∑* d) d n‚â°n (Empty-prop‚áî[Empty]-prop .proj‚ÇÅ prop)
  redSubst*Term t‚áíu (Unit·µ£ (Unit‚Çú D _)) ‚ä©u =
    case ‚ä©Unit‚à∑Unit‚áî‚ä©Unit‚â°‚à∑Unit .proj‚ÇÇ ‚ä©u of Œª
      (Unit‚Çú v u‚Üòv prop) ‚Üí
    Unit‚Çú‚Çå v v (‚áí*‚à∑‚Üí‚Üò‚à∑‚Üí‚Üò‚à∑ (conv* t‚áíu (subset* D)) u‚Üòv) u‚Üòv
      (Unit-prop‚áî[Unit]-prop .proj‚ÇÅ prop)
  redSubst*Term t‚áíu (ne‚Ä≤ _ _ D neK K‚â°K) ‚ä©u =
    let ne‚Çú k d (neNf‚Çú inc neK‚ÇÅ k‚â°k) = ‚ä©ne‚à∑‚áî‚ä©ne‚â°‚à∑ .proj‚ÇÇ ‚ä©u
        A‚â°K = subset* D
        d‚Ä≤  = conv* t‚áíu A‚â°K ‚á®‚à∑* d
    in
    ne‚Çú‚Çå k k d‚Ä≤ d (neNf‚Çú‚Çå inc neK‚ÇÅ neK‚ÇÅ k‚â°k)
  redSubst*Term t‚áíu (B·µ£ BŒ†! ‚ä©A@(B·µ£ F G D A‚â°A [F] [G] G-ext _)) [u] =
    let Œ†‚Çú f d funcF f‚â°f [f] = ‚ä©Œ†‚à∑‚áî‚ä©Œ†‚â°‚à∑ ‚ä©A .proj‚ÇÇ [u]
        d‚Ä≤   = conv* t‚áíu (subset* D) ‚á®‚à∑* d
    in
    Œ†‚Çú‚Çå f f d‚Ä≤ d funcF funcF f‚â°f
      (Œª [œÅ] [a] ‚Üí [f] [œÅ] (reflEqTerm ([F] [œÅ]) [a]))
  redSubst*Term t‚áíu (B·µ£ BŒ£À¢ ‚ä©A@(B·µ£ F G D A‚â°A [F] [G] G-ext _)) [u] =
    let Œ£‚Çú p d pProd p‚âÖp pProp = ‚ä©Œ£‚à∑‚áî‚ä©Œ£‚â°‚à∑ ‚ä©A .proj‚ÇÇ [u]
        d‚Ä≤ = conv* t‚áíu (subset* D) ‚á®‚à∑* d
    in
    Œ£‚Çú‚Çå p p d‚Ä≤ d pProd pProd p‚âÖp (Œ£-prop‚áî[Œ£]-prop .proj‚ÇÅ pProp)
  redSubst*Term t‚áíu (B·µ£ BŒ£ ∑ ‚ä©A@(B·µ£ F G D A‚â°A [F] [G] G-ext _)) [u] =
    case ‚ä©Œ£‚à∑‚áî‚ä©Œ£‚â°‚à∑ ‚ä©A .proj‚ÇÇ [u] of Œª where
      (Œ£‚Çú p d prod‚Çô p‚âÖp pProp) ‚Üí
        let d‚Ä≤ = conv* t‚áíu (subset* D) ‚á®‚à∑* d in
        Œ£‚Çú‚Çå p p d‚Ä≤ d prod‚Çô prod‚Çô p‚âÖp (Œ£-prop‚áî[Œ£]-prop .proj‚ÇÅ pProp)
      (Œ£‚Çú p d (ne x) p‚âÖp pProp) ‚Üí
        let d‚Ä≤ = conv* t‚áíu (subset* D) ‚á®‚à∑* d
        in
        Œ£‚Çú‚Çå p p d‚Ä≤ d (ne x) (ne x) p‚âÖp (Œ£-prop‚áî[Œ£]-prop .proj‚ÇÅ pProp)
  redSubst*Term {Œì} {A} {t} {l} t‚áí*u (Id·µ£ ‚ä©A) ‚ä©u =
    let Id‚Çú u‚Ä≤ u‚áí*u‚Ä≤ u‚Ä≤-id prop = ‚ä©Id‚à∑‚áî‚ä©Id‚â°‚à∑ ‚ä©A .proj‚ÇÇ ‚ä©u in
    _ , _ , conv* t‚áí*u (subset* ‚áí*Id) ‚á®‚à∑* u‚áí*u‚Ä≤ , u‚áí*u‚Ä≤ , u‚Ä≤-id ,
    u‚Ä≤-id , ‚ä©Id‚à∑-view‚áî .proj‚ÇÅ prop
    where
    open _‚ä©‚ÇóId_ ‚ä©A
  redSubst*Term t‚áíu (emb ‚â§·µò-refl     ‚ä©A) = redSubst*Term t‚áíu ‚ä©A
  redSubst*Term t‚áíu (emb (‚â§·µò-step p) ‚ä©A) = redSubst*Term t‚áíu (emb p ‚ä©A)

-- Weak head expansion of reducible types with single reduction step.
redSubst : ‚àÄ {A B : Term n} {l}
         ‚Üí Œì ‚ä¢ A ‚áí B
         ‚Üí Œì ‚ä©‚ü® l ‚ü© B
         ‚Üí ‚àÉ Œª ([A] : Œì ‚ä©‚ü® l ‚ü© A)
         ‚Üí Œì ‚ä©‚ü® l ‚ü© A ‚â° B / [A]
redSubst A‚áíB [B] = redSubst* (redMany-‚ä¢ A‚áíB) [B]

-- Weak head expansion of reducible terms with single reduction step.
redSubstTerm : ‚àÄ {A t u : Term n} {l}
             ‚Üí Œì ‚ä¢ t ‚áí u ‚à∑ A
             ‚Üí ([A] : Œì ‚ä©‚ü® l ‚ü© A)
             ‚Üí Œì ‚ä©‚ü® l ‚ü© u ‚à∑ A / [A]
             ‚Üí Œì ‚ä©‚ü® l ‚ü© t ‚â° u ‚à∑ A / [A]
redSubstTerm t‚áíu [A] [u] = redSubst*Term (redMany t‚áíu) [A] [u]

opaque

  -- If A is reducible and reduces to¬†B, then B is reducible and equal
  -- to¬†A.

  redSubst*‚Ä≤ :
    Œì ‚ä¢ A ‚áí* B ‚Üí (‚ä©A : Œì ‚ä©‚ü® l ‚ü© A) ‚Üí
    (Œì ‚ä©‚ü® l ‚ü© B) √ó Œì ‚ä©‚ü® l ‚ü© A ‚â° B / ‚ä©A
  redSubst*‚Ä≤ A‚áí*B ‚ä©U@(U·µ£‚Ä≤ l l< D) =
    case whrDet‚Üò (D , U‚Çô) A‚áí*B of Œª
      B‚áí*U ‚Üí
    U·µ£‚Ä≤ l l< B‚áí*U , B‚áí*U
  redSubst*‚Ä≤ A‚áí*B (‚Ñï·µ£ A‚áí*‚Ñï) =
    case whrDet‚Üò (A‚áí*‚Ñï , ‚Ñï‚Çô) A‚áí*B of Œª
      B‚áí*‚Ñï ‚Üí
    ‚Ñï·µ£ B‚áí*‚Ñï , B‚áí*‚Ñï
  redSubst*‚Ä≤ A‚áí*B (Empty·µ£ A‚áí*Empty) =
    case whrDet‚Üò (A‚áí*Empty , Empty‚Çô) A‚áí*B of Œª
      B‚áí*Empty ‚Üí
    Empty·µ£ B‚áí*Empty , B‚áí*Empty
  redSubst*‚Ä≤ A‚áí*B (Unit·µ£ (Unit‚Çú A‚áí*Unit ok)) =
    case whrDet‚Üò (A‚áí*Unit , Unit‚Çô) A‚áí*B of Œª
      B‚áí*Unit ‚Üí
    Unit·µ£ (Unit‚Çú B‚áí*Unit ok) , B‚áí*Unit
  redSubst*‚Ä≤ A‚áí*B (ne‚Ä≤ inc C A‚áí*C C-ne C‚âÖC) =
    case whrDet‚Üò (A‚áí*C , ne C-ne) A‚áí*B of Œª
      B‚áí*C ‚Üí
    ne‚Ä≤ inc C B‚áí*C C-ne C‚âÖC , ne‚Çå inc C B‚áí*C C-ne C‚âÖC
  redSubst*‚Ä≤ A‚áí*B (B·µ£‚Ä≤ W C D A‚áí*Œ†Œ£ Œ†Œ£‚â°Œ†Œ£ ‚ä©C ‚ä©D D‚â°D ok) =
    case whrDet‚Üò (A‚áí*Œ†Œ£ , ‚ü¶ W ‚üß‚Çô) A‚áí*B of Œª
      B‚áí*Œ†Œ£ ‚Üí
      B·µ£‚Ä≤ _ _ _ B‚áí*Œ†Œ£ Œ†Œ£‚â°Œ†Œ£ ‚ä©C ‚ä©D D‚â°D ok
    , B‚Çå _ _ B‚áí*Œ†Œ£ Œ†Œ£‚â°Œ†Œ£ (Œª _ ‚Üí reflEq (‚ä©C _)) (Œª _ _ ‚Üí reflEq (‚ä©D _ _))
  redSubst*‚Ä≤ A‚áí*B (Id·µ£ (Id·µ£ Ty lhs rhs A‚áí*Id ‚ä©Ty ‚ä©lhs ‚ä©rhs)) =
    case whrDet‚Üò (A‚áí*Id , Id‚Çô) A‚áí*B of Œª
      B‚áí*Id ‚Üí
      Id·µ£ (Id·µ£ Ty lhs rhs B‚áí*Id ‚ä©Ty ‚ä©lhs ‚ä©rhs)
    , Id‚Çå‚Ä≤ B‚áí*Id (reflEq ‚ä©Ty) (reflEqTerm ‚ä©Ty ‚ä©lhs)
        (reflEqTerm ‚ä©Ty ‚ä©rhs)
  redSubst*‚Ä≤ A‚áí*B (emb ‚â§·µò-refl ‚ä©A) =
      case redSubst*‚Ä≤ A‚áí*B ‚ä©A of Œª
        (‚ä©B , A‚â°B) ‚Üí (emb ‚â§·µò-refl ‚ä©B) ,
          (irrelevanceEq ‚ä©A (emb ‚â§·µò-refl ‚ä©A) A‚â°B)
  redSubst*‚Ä≤ A‚áí*B (emb (‚â§·µò-step p) ‚ä©A) =
      case redSubst*‚Ä≤ A‚áí*B (emb p ‚ä©A) of Œª
        (‚ä©B , A‚â°B) ‚Üí
        emb-<-‚ä© ‚â§·µò-refl ‚ä©B
      , irrelevanceEq (emb p ‚ä©A) (emb (‚â§·µò-step p) ‚ä©A) A‚â°B

opaque

  -- If t is reducible and reduces to¬†u, then u is "reducibly equal"
  -- to¬†t.

  redSubst*Term‚Ä≤ :
    Œì ‚ä¢ t ‚áí* u ‚à∑ A ‚Üí (‚ä©A : Œì ‚ä©‚ü® l ‚ü© A) ‚Üí Œì ‚ä©‚ü® l ‚ü© t ‚à∑ A / ‚ä©A ‚Üí
    Œì ‚ä©‚ü® l ‚ü© t ‚â° u ‚à∑ A / ‚ä©A
  redSubst*Term‚Ä≤ t‚áí*u ‚ä©U@(U·µ£‚Ä≤ l ‚â§·µò-refl D) ‚ä©t =
    let U‚Çú A t‚áí*A A-type A‚âÖA ‚ä©t = ‚ä©U‚à∑U‚áî‚ä©U‚â°‚à∑U .proj‚ÇÇ ‚ä©t in
    case whrDet‚ÜòTerm (t‚áí*A , typeWhnf A-type)
           (conv* t‚áí*u (subset* D)) of Œª
      u‚áí*A ‚Üí
      case redSubst*‚Ä≤ (univ* (conv* t‚áí*u (subset* D))) ‚ä©t of Œª
        (‚ä©u , t‚â°u) ‚Üí
    U‚Çú‚Çå A A t‚áí*A u‚áí*A A-type A-type A‚âÖA ‚ä©t ‚ä©u t‚â°u
  redSubst*Term‚Ä≤ t‚áí*u ‚ä©U@(U·µ£‚Ä≤ l (‚â§·µò-step l<) D) ‚ä©t =
    let U‚Çú A t‚áí*A A-type A‚âÖA ‚ä©t = ‚ä©U‚à∑U‚áî‚ä©U‚â°‚à∑U .proj‚ÇÇ ‚ä©t in
    irrelevanceEqTerm (U·µ£‚Ä≤ l l< D) ‚ä©U
      (redSubst*Term‚Ä≤ t‚áí*u (U·µ£‚Ä≤ l l< D)
         (‚ä©U‚à∑U‚áî‚ä©U‚â°‚à∑U .proj‚ÇÅ (U‚Çú A t‚áí*A A-type A‚âÖA ‚ä©t)))
  redSubst*Term‚Ä≤ t‚áí*u (‚Ñï·µ£ A‚áí*‚Ñï) ‚ä©t =
    let ‚Ñï‚Çú v t‚áí*v v‚âÖv v-ok = ‚ä©‚Ñï‚à∑‚Ñï‚áî‚ä©‚Ñï‚â°‚à∑‚Ñï .proj‚ÇÇ ‚ä©t in
    case whrDet‚ÜòTerm (t‚áí*v , naturalWhnf (natural v-ok))
           (conv* t‚áí*u (subset* A‚áí*‚Ñï)) of Œª
      u‚áí*v ‚Üí
    ‚Ñï‚Çú‚Çå v v t‚áí*v u‚áí*v v‚âÖv (Natural-prop‚áî[Natural]-prop .proj‚ÇÅ v-ok)
  redSubst*Term‚Ä≤ t‚áí*u (Empty·µ£ A‚áí*Empty) ‚ä©t =
    let Empty‚Çú v t‚áí*v v‚âÖv v-ok = ‚ä©Empty‚à∑Empty‚áî‚ä©Empty‚â°‚à∑Empty .proj‚ÇÇ ‚ä©t in
    case whrDet‚ÜòTerm (t‚áí*v , ne (empty v-ok))
           (conv* t‚áí*u (subset* A‚áí*Empty)) of Œª
      u‚áí*v ‚Üí
    Empty‚Çú‚Çå v v t‚áí*v u‚áí*v v‚âÖv (Empty-prop‚áî[Empty]-prop .proj‚ÇÅ v-ok)
  redSubst*Term‚Ä≤ t‚áí*u (Unit·µ£ (Unit‚Çú A‚áí*Unit _)) ‚ä©t =
    case ‚ä©Unit‚à∑Unit‚áî‚ä©Unit‚â°‚à∑Unit .proj‚ÇÇ ‚ä©t of Œª
      (Unit‚Çú v t‚Üòv@(_ , v-whnf) prop) ‚Üí
    Unit‚Çú‚Çå v v t‚Üòv
      (whrDet‚ÜòTerm t‚Üòv (conv* t‚áí*u (subset* A‚áí*Unit)) , v-whnf)
      (Unit-prop‚áî[Unit]-prop .proj‚ÇÅ prop)
  redSubst*Term‚Ä≤ t‚áí*u (ne‚Ä≤ _ B A‚áí*B B-ne B‚âÖB) ‚ä©t =
    let ne‚Çú v t‚áí*v prop@(neNf‚Çú _ v-ne _) = ‚ä©ne‚à∑‚áî‚ä©ne‚â°‚à∑ .proj‚ÇÇ ‚ä©t
        u‚áí*v = whrDet‚ÜòTerm (t‚áí*v , ne v-ne) (conv* t‚áí*u (subset* A‚áí*B))
    in
    ne‚Çú‚Çå v v t‚áí*v u‚áí*v (‚ä©neNf‚à∑‚áî‚ä©neNf‚â°‚à∑ .proj‚ÇÅ prop)
  redSubst*Term‚Ä≤ t‚áí*u (B·µ£ BŒ†! ‚ä©A@(B·µ£ C D A‚áí*Œ† Œ†‚â°Œ† ‚ä©C ‚ä©D D‚â°D ok)) ‚ä©t =
    let Œ†‚Çú v t‚áí*v v-fun ‚âÖv ‚ä©v = ‚ä©Œ†‚à∑‚áî‚ä©Œ†‚â°‚à∑ ‚ä©A .proj‚ÇÇ ‚ä©t
        u‚áí*v = whrDet‚ÜòTerm (t‚áí*v , functionWhnf v-fun)
                 (conv* t‚áí*u (subset* A‚áí*Œ†))
    in
    v , v , t‚áí*v , u‚áí*v , v-fun , v-fun , ‚âÖv , ‚ä©v
  redSubst*Term‚Ä≤
    t‚áí*u (B·µ£ (BŒ£ s _ _) ‚ä©A@(B·µ£ C D A‚áí*Œ£ Œ£‚â°Œ£ ‚ä©C ‚ä©D D‚â°D ok)) ‚ä©t =
    let Œ£‚Çú v t‚áí*v v-prod ‚âÖv prop = ‚ä©Œ£‚à∑‚áî‚ä©Œ£‚â°‚à∑ ‚ä©A .proj‚ÇÇ ‚ä©t
        u‚áí*v = whrDet‚ÜòTerm (t‚áí*v , productWhnf v-prod)
                 (conv* t‚áí*u (subset* A‚áí*Œ£))
    in
    v , v , t‚áí*v , u‚áí*v , ‚âÖv , v-prod , v-prod ,
    Œ£-prop‚áî[Œ£]-prop .proj‚ÇÅ prop
  redSubst*Term‚Ä≤ t‚áí*u (Id·µ£ ‚ä©A@(Id·µ£ Ty lhs rhs A‚áí*Id ‚ä©Ty ‚ä©lhs ‚ä©rhs)) ‚ä©t =
    let Id‚Çú v t‚áí*v v-id prop = ‚ä©Id‚à∑‚áî‚ä©Id‚â°‚à∑ ‚ä©A .proj‚ÇÇ ‚ä©t
        u‚áí*v = whrDet‚ÜòTerm (t‚áí*v , identityWhnf v-id)
                 (conv* t‚áí*u (subset* A‚áí*Id))
    in
    v , v , t‚áí*v , u‚áí*v , v-id , v-id , ‚ä©Id‚à∑-view‚áî .proj‚ÇÅ prop
  redSubst*Term‚Ä≤ t‚áí*u (emb ‚â§·µò-refl ‚ä©A)     = redSubst*Term‚Ä≤ t‚áí*u ‚ä©A
  redSubst*Term‚Ä≤ t‚áí*u (emb (‚â§·µò-step p) ‚ä©A) =
    redSubst*Term‚Ä≤ t‚áí*u (emb p ‚ä©A)
