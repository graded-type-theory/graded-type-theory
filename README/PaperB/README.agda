------------------------------------------------------------------------
-- Code related to the paper "A Resource-Correct Graded Modal Dependent
-- Type Theory with Recursion, Formalized" by Oskar Eriksson, Nils
-- Anders Danielsson and Andreas Abel.
------------------------------------------------------------------------

-- Currently, the paper is not published and the code in this file
-- refers to a preliminary version.
--
-- Note that Andreas Abel, Nils Anders Danielsson, Oskar Eriksson,
-- Ga√´tan Gilbert, Ond≈ôej Kub√°nek, Wojciech Nawrocki, Joakim √ñhman and
-- Andrea Vezzosi have also contributed to the code.
--
-- The code also depends on some libraries:
--
-- * Agda's standard library, version¬†2.1.
-- * The builtin modules that are shipped with Agda¬†2.7.0.1.
--
-- When HTML code is generated from this file code is also generated
-- for the two libraries above, so URLs for their licences are
-- included here. At the time of writing the licence texts can be
-- found at the following URLs:
--
-- * https://github.com/agda/agda-stdlib/blob/v2.1/LICENCE
-- * https://github.com/agda/agda/blob/v2.7.0.1/LICENSE

module README.PaperB.README where

import Definition.Typed
import Definition.Typed.Consequences.Inversion
import Definition.Typed.Consequences.Reduction
import Definition.Typed.Inversion
import Definition.Typed.Properties.Reduction
import Definition.Typed.Restrictions
import Definition.Untyped
import Definition.Untyped.NotParametrised

import Graded.Context
import Graded.Context.Properties.Natrec
import Graded.Context.Properties.PartialOrder
import Graded.Context.Weakening
import Graded.Erasure.Consequences.Soundness
import Graded.Heap.Assumptions
import Graded.Heap.Bisimilarity
import Graded.Heap.Examples
import Graded.Heap.Examples.Linearity
import Graded.Heap.Normalization
import Graded.Heap.Reduction
import Graded.Heap.Reduction.Properties
import Graded.Heap.Soundness
import Graded.Heap.Soundness.Counterexample
import Graded.Heap.Termination
import Graded.Heap.Typed
import Graded.Heap.Typed.Properties
import Graded.Heap.Typed.Reduction
import Graded.Heap.Untyped
import Graded.Heap.Untyped.Properties
import Graded.Heap.Usage
import Graded.Heap.Usage.Inversion
import Graded.Heap.Usage.Properties
import Graded.Heap.Usage.Reduction
import Graded.Modality
import Graded.Modality.Instances.Affine
import Graded.Modality.Instances.Erasure.Modality
import Graded.Modality.Instances.Erasure.Properties
import Graded.Modality.Instances.Examples
import Graded.Modality.Instances.Linearity
import Graded.Modality.Instances.Linearity.Bad
import Graded.Modality.Instances.Linearity.Bad.No-dedicated-nr
import Graded.Modality.Instances.Linearity.Good.Greatest-lower-bound
import Graded.Modality.Instances.Nat
import Graded.Modality.Instances.Nat-plus-infinity
import Graded.Modality.Instances.Set
import Graded.Modality.Instances.Zero-one-many
import Graded.Modality.Properties.Addition
import Graded.Modality.Properties.Greatest-lower-bound
import Graded.Modality.Properties.Has-well-behaved-zero
import Graded.Modality.Properties.Natrec
import Graded.Modality.Properties.PartialOrder
import Graded.Modality.Properties.Star
import Graded.Modality.Properties.Subtraction
import Graded.Modality.Variant
import Graded.Mode
import Graded.Reduction
import Graded.Substitution.Properties
import Graded.Usage
import Graded.Usage.Inversion
import Graded.Usage.Restrictions
import Graded.Usage.Weakening

import Tools.Fin
import Tools.Nat

------------------------------------------------------------------------
-- Differences between the paper and the code
------------------------------------------------------------------------

-- The code does not follow the paper exactly. Notably, the
-- formalisation contains parameters that make it possible to control
-- whether certain features should be included or not (in addition to
-- the possibility to choose what modality to use). The three most
-- prominent parameters are `Modality-variant`, `Type-restrictions` and
-- `Usage-restrictions`. The presentation in the paper is done for
-- certain instantiations of these parameters as discussed below:

-- Modality-variant controls whether the usage relation should support
-- one or two modes. In the paper, we use two modes but our results hold
-- also for the theory with one mode.

Modality-variant = Graded.Modality.Variant.Modality-variant

-- Type-restrictions control the typing judgments and the reduction
-- relation.

Type-restrictions = Definition.Typed.Restrictions.Type-restrictions

-- One can choose whether to allow strong and/or weak unit types as well
-- as binders of the form B_p^q, where p and q are grades and B is "Œ†",
-- "strong Œ£" or "weak Œ£".
--
-- If a term has a certain type ("Unit" or "B_p^q¬†C¬†D"), then this type
-- must be allowed by the Type-restrictions:

Unit-allowed = Definition.Typed.Inversion.‚ä¢‚à∑Unit‚ÜíUnit-allowed
Œ†Œ£-allowed   = Definition.Typed.Inversion.‚ä¢‚à∑Œ†Œ£‚ÜíŒ†Œ£-allowed

-- In the paper, we do not have such restrictions (i.e. these types are
-- always allowed) but our results hold also if such restrictions are
-- included. Similar choices can also be made for certain terms related
-- to identity types. We do not discuss these in the paper but again our
-- results hold regardless of whether these are allowed or not.

-- One can choose to allow a form of Œ∑-equality for the weak unit type.
-- Enabling this rule changes the definition of typing and reduction for
-- the weak unit element and unitrec.
--
-- In the paper, this is not enabled but a version of our results hold
-- also when it is. In order to be consistent with the reduction, the
-- rules for machine transitions are changed slightly and some
-- properties (including our main correctness theorem) are shown under
-- an additional assumption:

Unit ∑-Œ∑-assumption = Graded.Heap.Assumptions.Assumptions.Unit ∑-Œ∑‚Üí

-- One can choose whether to allow equality reflection. We do not
-- discuss equality types in the paper so this is of no consequence in
-- that regard. The formalized results hold for closed terms when this
-- is enabled. For open terms our proof holds only with equality
-- reflection turned off.

-- Usage-restrictions control the usage relation.

Usage-restrictions = Graded.Usage.Restrictions.Usage-restrictions

-- One can choose for some terms which grade annotations should be
-- allowed (for a given mode). This corresponds to the side conditions
-- for some usage rules in the paper. For the terms presented in the
-- paper this is available for prodrec_r^p, unitrec_p, and emptyrec_p.
--
-- If a certain term is well-resourced then (with respect to a given
-- mode) then the term is allowed for that mode.

prodrec-allowed = Graded.Usage.Inversion.inv-usage-prodrec
unitrec-allowed = Graded.Usage.Inversion.inv-usage-unitrec
emptyrec-allowed = Graded.Usage.Inversion.inv-usage-emptyrec

-- One can choose whether the strong unit element should be
-- well-resourced in any context (as opposed to only in the zero
-- context). In the presentation used in the paper this is allowed but
-- the results hold either way.

-- One can choose between three mutually exclusive usage rules for
-- natrec. One corresponds to the usage rule using the natrec-star
-- operator, one corresponds to the usage rule we define in the paper
-- and the third is only mentioned briefly in the paper. We have not
-- shown that our results hold when this usage rule is used.

------------------------------------------------------------------------
-- Pointers to results from the paper
------------------------------------------------------------------------

-- The remainder of this file contains pointers to results from the
-- paper.

------------------------------------------------------------------------
-- 2: A Graded Modal Dependent Type Theory

------------------------------------------------------------------------
-- 2.1: Modalities

-- Definition 2.1: Modalities.
--
-- The formalized definition differs somewhat from the definition in the
-- paper:
--
-- In the formalization, a modality comes with an additional
-- special grade œâ which is assumed to satisfy certain properties. This
-- grade is used to state the usage rules for the eliminators for the
-- identity type which we do not include in the paper.
--
-- Equality between grades is not assumed to be decidable in general but
-- it is decidable whether a grade is equal to zero.
--
-- Modality records contain a field of type Modality-variant in addition
-- to the algebraic structure which is referred to as
-- `Semiring-with-meet` in the formalization.

Modality = Graded.Modality.Modality
Semiring-with-meet = Graded.Modality.Semiring-with-meet

-- Sets of natural numbers are not generally modalities

set-no-modality = Graded.Modality.Instances.Set.ùüô-ùüö.no-modality

-- The partial order relation for modalities

_‚â§_ = Graded.Modality.Modality._‚â§_

-- The order is a partial order

‚â§-partial-order = Graded.Modality.Properties.PartialOrder.‚â§-poset

-- Definition 2.2: Modalities with a well-behaved zero.

-- The property of having a well-behaved zero is defined for
-- `Semiring-with-meet`, the algebraic structure of the modality.

Has-well-behaved-zero = Graded.Modality.Has-well-behaved-zero

-- The formalized definition does not require q¬†‚â°¬†ùüò to follow from
-- p¬†+¬†q¬†‚â°¬†ùüò or p¬†‚àß¬†q¬†‚â°¬†ùüò. This follows from commutativity of the
-- operators.

+-positive ≥ =
  Graded.Modality.Properties.Has-well-behaved-zero.+-positive ≥
‚àß-positive ≥ =
  Graded.Modality.Properties.Has-well-behaved-zero.‚àß-positive ≥

-- Example modalities.
--
-- All these modality definitions takes an argument of type
-- `Modality-variant`. The modalities can thus be defined to support
-- either the moded or non-moded usage relation.

-- The erasure modality.

erasureModality =
  Graded.Modality.Instances.Erasure.Modality.ErasureModality

-- The affine types modality

affineTypesModality =
  Graded.Modality.Instances.Linearity.linearityModality

-- The linear types modality.

linearTypesModality =
  Graded.Modality.Instances.Linearity.linearityModality

-- The "natural numbers" instances

-- The definition takes a boolean argument, controlling which of the two
-- order relations should be used.
--
-- In the formalization, the grade ‚àû is used to represent any number of
-- uses. In the paper we refer to this grade as œâ.

‚Ñïœâ-Modality = Graded.Modality.Instances.Nat-plus-infinity.‚Ñï‚äé‚àû-Modality

------------------------------------------------------------------------
-- 2.2: Syntax, Typing and Usage

-- de Bruijn index
--
-- In the formalization, de Bruijn indices are represented as the type
-- `Fin`, unlike the paper which uses `Nat`. This representation ensures
-- that the syntax is well-scoped since out-of-scope variable indices
-- cannot occur.

de-Bruijn-index = Tools.Fin.Fin

-- Universe level

Universe-level = Definition.Untyped.NotParametrised.Universe-level

-- Grade
--
-- Grades are elements of the chosen modality

grade = Graded.Modality.Modality

-- Strength

Strength = Definition.Untyped.NotParametrised.Strength

-- Term
--
-- The type of terms is indexed by a natural number, representing the
-- number of free variables it has. The representation of de Bruijn
-- indices (discussed above) ensures that no variable indices are
-- out-of-scope, making the syntax well-scoped.
--
-- The syntax defined in the formalization is the full syntax, including
-- terms which we do not discuss in this section or in the paper at all.
-- In particular, this includes `natrec`, the eliminator for natural
-- numbers and the terms related to the Identity type (`Id`, `rfl`, `J`,
-- `K`, and `[]-cong`).
--
-- In the formalized syntax, Œ† and Œ£-types have been merged. The
-- corresponding type constructor takes an argument of type `BinderMode`
-- which determines whether the term is a Œ†-type or a Œ£-type (as well as
-- the strength in the latter case). This is done to aid the
-- formalization effort and reduce code duplication since the two types
-- can often be treated the same in proofs.
--
-- Another difference is that the unit types exist at any universe level
-- unlike in the paper where we define them at level 0 for simplicity.
-- In the formalized syntax, the terms for the unit types, unit elements
-- and `unitrec`, the eliminator for the weak unit type, all take an
-- argument of type `Universe-level`. The version of this theory that
-- is presented in the paper always set these to zero.
--
-- Some terms come with an additional grade annotation which is used to
-- assign a grade to the variable bound by the motive of eliminators.
-- For the usage relation with two modes, this is forced to be zero so
-- we have left out this grade in the paper.

Term = Definition.Untyped.Term

-- Weakening

Weakening = Definition.Untyped.NotParametrised.Wk

-- Typing context
--
-- Typing contexts are also well-scoped. The first term in a context is
-- closed and each consequent term (can) contain an additional variable.

Con = Definition.Untyped.NotParametrised.Con

-- Grade context

Con‚Çò = Graded.Context.Con‚Çò

-- Mode
--
-- As explained above, a modality can either support the two-moded usage
-- relation or not using the `Modality-variant` field of the modality.
-- The type `Mode` contains two elements if the chosen modality supports
-- the moded usage relation and one element if it does not. Again, in
-- the theory presented in the paper, we are using two modes.

Mode = Graded.Mode.Mode

-- Weakenings applied to variable indices. In the paper, the notation
-- _[_] is used for this operation.

wkVar = Definition.Untyped.NotParametrised.wkVar

-- Weakenings applied to terms. In the paper, the notation
-- _[_] is used for this operation.

wk = Definition.Untyped.wk

-- The weakenings ‚Üë‚Åø and ‚áë‚Åø

‚Üë‚Åø = Definition.Untyped.NotParametrised.stepn
‚áë‚Åø = Definition.Untyped.NotParametrised.liftn

-- Substitutions

Subst = Definition.Untyped.Subst

-- Application of substitutions to terms

_[_] = Definition.Untyped._[_]

-- Extending a substitution œÉ with a term t.

consSubst = Definition.Untyped.consSubst

-- Substituting a single variable

_[_]‚ÇÄ = Definition.Untyped._[_]‚ÇÄ

-- Composition of substitutions
--
-- There are four composition operators for composing weakenings and
-- substitutions. In the paper we treat weakenings and substitutions the
-- same and use only one composition operator for all cases. Note that
-- the formalization uses a different symbol for composition than the
-- paper

-- Composing two substitutions

_‚Çõ‚Ä¢‚Çõ_ = Definition.Untyped._‚Çõ‚Ä¢‚Çõ_

-- Composing two weakenings

_‚Ä¢_ = Definition.Untyped.NotParametrised._‚Ä¢_

-- Composing a weakening with a substitution

_‚Ä¢‚Çõ_ = Definition.Untyped._‚Ä¢‚Çõ_

-- Composing a substitution with a weakening

_‚Çõ‚Ä¢_ = Definition.Untyped._‚Çõ‚Ä¢_

-- Weakening for substitutions

‚ÜëÀ¢ = Definition.Untyped.wk1Subst
‚áëÀ¢ = Definition.Untyped.liftSubst

-- The type system
--
-- Like the syntax, the typing judgements are defined for the whole
-- language, including those terms which are not covered by this
-- section or the paper.

-- Well-formed contexts

‚ä¢_ = Definition.Typed.‚ä¢_

-- Well-formed types

_‚ä¢_ = Definition.Typed._‚ä¢_

-- Well-formed terms

_‚ä¢_‚à∑_ = Definition.Typed._‚ä¢_‚à∑_

-- Definitional equality for types

_‚ä¢_‚â°_ = Definition.Typed._‚ä¢_‚â°_

-- Definitional equality for terms

_‚ä¢_‚â°_‚à∑_ = Definition.Typed._‚ä¢_‚â°_‚à∑_

-- Well-formed variables

_‚à∑_‚àà_ = Definition.Typed._‚à∑_‚àà_

-- Max for universe levels

_‚äî_ = Definition.Untyped.NotParametrised._‚äî·µò_

-- Well-typed applications to lambdas have matching grades

‚ä¢Œª ≥t·µñu‚Üíp‚â°r = Definition.Typed.Consequences.Inversion.inversion-lam-app

-- The usage relation
--
-- Like the syntax and typing judgements, the usage relation is defined
-- for the whole language, including those terms which are not covered
-- by this section or the paper.

_‚ñ∏[_]_ = Graded.Usage._‚ñ∏[_]_

-- Grade context lookup

_‚ü®_‚ü© = Graded.Context._‚ü®_‚ü©

-- Lifted operators and order relation to grade contexts

_+·∂ú_ = Graded.Context._+·∂ú_
_‚àß·∂ú_ = Graded.Context._‚àß·∂ú_
_¬∑·∂ú_ = Graded.Context._¬∑·∂ú_
_‚â§·∂ú_ = Graded.Context._‚â§·∂ú_

-- The lifted order relation is a partial order

‚â§·∂ú-partial-order = Graded.Context.Properties.PartialOrder.‚â§·∂ú-poset

-- Conversion between grades and modes.
--
-- In the paper we implicitly convert from modes to grades. In the
-- formalization, these are explicit.

-- Conversion from grades to modes

‚åû_‚åü = Graded.Mode.‚åû_‚åü

-- Conversion from modes to grades

‚åú_‚åù = Graded.Mode.‚åú_‚åù

-- Weakening of usage contexts
--
--  In the paper, the notation _[_] is used for this operation.

wkCon‚Çò = Graded.Context.Weakening.wkCon‚Çò

-- Usage is preserved by weakening

wkUsage = Graded.Usage.Weakening.wkUsage

-- The call-by-name, weak-head reduction relation.

_‚ä¢_‚áí_‚à∑_ = Definition.Typed._‚ä¢_‚áí_‚à∑_

-- The reflexive, transitive closure of the reduction relation.

_‚ä¢_‚áí*_‚à∑_ = Definition.Typed._‚ä¢_‚áí*_‚à∑_

-- Reduction is deterministic

‚áí-deterministic = Definition.Typed.Properties.Reduction.whrDetTerm

-- Well-typed terms reduce to WHNF.

redWhnf = Definition.Typed.Consequences.Reduction.whNormTerm

-- Terms in WHNF do not reduce.

whnfNoRed = Definition.Typed.Properties.Reduction.whnfRedTerm

------------------------------------------------------------------------
-- 3: A Resource Aware Abstract Machine

------------------------------------------------------------------------
-- 3.1: Subtraction of Grades

-- Definition 3.1: Subtraction

_-_‚â§_ = Graded.Modality.Properties.Subtraction._-_‚â§_
_-_‚â°_ = Graded.Modality.Properties.Subtraction._-_‚â°_

-- Theorem 3.2: Properties of Subtraction

-- Subtraction is functional

-‚â°-functional = Graded.Modality.Properties.Subtraction.-‚â°-functional

-- Subtraction is monotone in its first argument

-‚â°-monotoneÀ° = Graded.Modality.Properties.Subtraction.-‚â°-monotoneÀ°

-- Subtraction is antitone in its second argument

-‚â°-antitone ≥ = Graded.Modality.Properties.Subtraction.-‚â°-antitone ≥

-- Subtraction by zero is the identity

-ùüò‚â° = Graded.Modality.Properties.Subtraction.p-ùüò‚â°p

-- Subtraction of the least grade is the identity

œâ-‚â° = Graded.Modality.Properties.Subtraction.‚àû-p‚â°‚àû

-- Subtraction of zero by is only possible by zero.

ùüò-‚â° = Graded.Modality.Properties.Subtraction.ùüò-p‚â°q

-- Modalities supporting subtraction

Supports-subtraction =
  Graded.Modality.Properties.Subtraction.Supports-subtraction

-- The example modalities support subtraction and defines subtraction as
-- specified in the paper.
--
-- To help illustrate the latter point, we link here to alternative
-- subtraction relations (for each instance) from which it is clearer
-- for which grades subtraction is defined and what the result is.
-- These relations are proved to be equivalent to the proper subtraction
-- relation.

erasure-supports-subtraction =
  Graded.Modality.Instances.Erasure.Properties.supports-subtraction
erasure-subtraction-def =
  Graded.Modality.Instances.Erasure.Properties._-_‚â°‚Ä≤_
erasure-subtraction-def-correct =
  Graded.Modality.Instances.Erasure.Properties.-‚â°‚Üî-‚â°‚Ä≤

affine-supports-subtraction =
  Graded.Modality.Instances.Zero-one-many.supports-subtraction
affine-subtraction-def =
  Graded.Modality.Instances.Zero-one-many._-_‚â°‚Ä≤_
affine-subtraction-def-correct =
  Graded.Modality.Instances.Zero-one-many.-‚â°‚Üî-‚â°‚Ä≤

linearity-supports-subtraction =
  Graded.Modality.Instances.Zero-one-many.supports-subtraction
linearity-subtraction-def =
  Graded.Modality.Instances.Zero-one-many._-_‚â°‚Ä≤_
linearity-subtraction-def-correct =
  Graded.Modality.Instances.Zero-one-many.-‚â°‚Üî-‚â°‚Ä≤

‚Ñïœâ-supports-subtraction =
  Graded.Modality.Instances.Nat-plus-infinity.supports-subtraction
‚Ñïœâ-subtraction-def =
  Graded.Modality.Instances.Nat-plus-infinity._-_‚â°‚Ä≤_
‚Ñïœâ-subtraction-def-correct =
  Graded.Modality.Instances.Nat-plus-infinity.-‚â°‚Üî-‚â°‚Ä≤

------------------------------------------------------------------------
-- 3.2: The Abstract Machine

-- In this, and following sections, we define the abstract machine for
-- a subset of the formalized language. In particular, we do not include
-- natrec or identity types. The formalization, however, includes these.
-- This means that some properties do not hold exactly as stated in this
-- section. We discuss such cases in more detail below.
--
-- Another difference between the presentation in this section and the
-- formalization is that we only consider closed terms at this point
-- though the formalization allows open terms. Again, we discuss this
-- further below.
--
-- Also note that we have assumed to be working with a modality
-- supporting subtraction and with a well-behaved zero. Some properties
-- mentioned below are proved under these assumptions.

-- Heap entries
--
-- The type of heap entries is indexed by two natural numbers which
-- denote the size of the heap in which the entry lives and the number
-- of free variables of its term.

Entry = Graded.Heap.Untyped.Entry

-- Heaps
--
-- The type of heaps is indexed by two natural numbers. The first is the
-- size of the heap (the total number of entries) and is used to ensure
-- well-scopedness (that is, ensuring that pointers have a corresponding
-- entry). The second index represents the number of dummy indices the
-- heap contains. In this section, we do not consider heaps with
-- dummy entries and consequently require this index to always be zero.

Heap = Graded.Heap.Untyped.Heap

-- Continuations
--
-- Continuations are indexed by one natural number, representing the
-- size of the heap to which it is associated. Again, this is used to
-- achieve well-scopedness.
--
-- The formalization contains additional continuations compared to the
-- paper, corresponding to natrec and the eliminators related to
-- the identity type.
--
-- Some continuations have an additional grade annotation than in the
-- paper. This corresponds to the extra annotations for terms explained
-- above.

Continuation = Graded.Heap.Untyped.Cont

-- Stacks
--
-- Stacks are indexed in the same way as continuations.

Stack = Graded.Heap.Untyped.Stack

-- Machine states
--
-- Machine states are parametrized by three natural numbers. One
-- corresponds to the size of the heap, one to the number of free
-- variables of the head (these two ensure that the weakening contains
-- translations from variable indices to pointer indices). The last
-- index represents the number of dummy entries in the heap. Again, this
-- is zero in this section.

State = Graded.Heap.Untyped.State

-- Lookup with heap update
--
-- In the paper the number of copies to look up is written as a
-- superscript. In the formalization it is written inside brackets.

_‚ä¢_‚Ü¶[_]_‚®æ_ = Graded.Heap.Untyped._‚ä¢_‚Ü¶[_]_‚®æ_

-- Lookup can fail if the heap does not contain enough resources (as
-- determined by the subtraction of the modality).

-‚â¢-no-lookup = Graded.Heap.Untyped.Properties.-‚â¢-no-lookup

-- Lookup without heap update.

_‚ä¢_‚Ü¶_ = Graded.Heap.Untyped._‚ä¢_‚Ü¶_

-- Heap lookup without heap update always succeeds. This property is
-- proven under the assumption that the heap does not contain dummy
-- entries as is the case in this section.

‚ä¢‚Ü¶-succeeds = Graded.Heap.Untyped.Properties.¬¨erased-heap‚Üí‚Ü¶

-- Heaps as substitutions

‚¶Ö_‚¶Ü ∞ = Graded.Heap.Untyped.toSubst‚Çï

-- Applying a term to a continuation

‚¶Ö_‚¶Ü·∂ú_ = Graded.Heap.Untyped.‚¶Ö_‚¶Ü·∂ú_

-- Applying a term to a stack

‚¶Ö_‚¶ÜÀ¢_ = Graded.Heap.Untyped.‚¶Ö_‚¶ÜÀ¢_

-- Translating a state into a term.

‚¶Ö_‚¶Ü = Graded.Heap.Untyped.‚¶Ö_‚¶Ü

-- Initial states

initial = Graded.Heap.Untyped.initial

-- Multiplicity of a stack.

‚à£_‚à£‚â°_ = Graded.Heap.Untyped.‚à£_‚à£‚â°_

-- Multiplicity of a continuation

‚à£_‚à£·∂ú‚â°_ = Graded.Heap.Untyped.‚à£_‚à£·∂ú‚â°_

-- The multiplicity of a stack is unique (if it exists).

‚à£‚à£-functional = Graded.Heap.Untyped.Properties.‚à£‚à£-functional

-- The multiplicity of a stack always exists.
--
-- This property does not hold as stated since the formalization
-- contains natrec while the paper does not (in this section). The
-- linked property contains an additional assumption that the stack does
-- not contain any continuations corresponding to natrec.

‚àÉ‚à£‚à£‚â° = Graded.Heap.Untyped.Properties.nr‚àâ-‚à£‚à£‚â°

-- The property that a stack contains a natrec continuation

natrec‚àà = Graded.Heap.Untyped.natrec_,_‚àà

-- Reduction of eliminators and variables

_‚áæ‚Çë_ = Graded.Heap.Reduction._‚áæ‚Çë_

-- This relation is defined using an auxiliary reduction relation that
-- excludes the variable rule. The reduction without tracking is defined
-- using the same auxiliary reduction.

_‚áí‚Çë_ = Graded.Heap.Reduction._‚áí‚Çë_

-- Reduction of values

_‚áí·µ•_ = Graded.Heap.Reduction._‚áí·µ•_

-- The weak head semantics of the machine.

_‚áæ_ = Graded.Heap.Reduction._‚áæ_

-- The reflexive, transitive closure of the weak head semantics.

_‚áæ*_ = Graded.Heap.Reduction._‚áæ*_

-- States with variables in head position can get stuck if the heap
-- does not contain enough resources to perform a lookup.

var-noRed = Graded.Heap.Reduction.Properties.var-noRed

-- Evaluation in _‚áí·µ•_ can fail if the head does not match the stack
--
-- A term is said to be matching a stack if it is a value and the
-- continuation on top of the stack corresponds to an eliminator for
-- that value.

‚áí·µ•-noRed = Graded.Heap.Reduction.Properties.¬¨Matching‚Üí¬¨‚áíÃ¨
Matching = Graded.Heap.Untyped.Matching

-- Weakening of stacks. In the paper, the notation _[_] is used for
-- this operation.

wkÀ¢ = Graded.Heap.Untyped.wkÀ¢

-- The stack multiplicity is zero iff it contains erased prodrec,
-- unitrec or emptyrec.
--
-- Because the formalized theory contains natrec and identity types,
-- this property does not hold exactly as stated. The first direction,
-- showing that the stack multiplicity is zero if the stack contains
-- an erased prodrec, unitrec, or emptyrec assumes that the stack
-- multiplicity exists. As discussed above, this is the case if the
-- stack does not contain any natrec eliminators.
--
-- The second direction, showing that the stack contains erased prodrec,
-- unitrec, or emptyrec if the stack multiplicity is zero does not
-- necessarily hold if the stack contains continuations related to the
-- identity type since these can have multiplicity zero. In the linked
-- property, we have shown that the stack contains erased prodrec,
-- unitrec or emptyrec or a continuation related the identity type (J,
-- K, or []-cong).

‚à£‚à£‚â°ùüò-if-erased-elim = Graded.Heap.Untyped.Properties.nr‚àâ‚Üí‚à£‚à£‚â°ùüò
erased-elim-if-‚à£‚à£‚â°ùüò = Graded.Heap.Untyped.Properties.‚à£‚à£‚â°ùüò‚Üíerased-match

-- Reduction of eliminators and variables without resource tracking

_‚á¢‚Çë_ = Graded.Heap.Reduction._‚á¢‚Çë_

-- The weak head semantics without resource tracking.

_‚á¢_ = Graded.Heap.Reduction._‚á¢_

-- Reduction for numerals

_‚áí‚Çô_ = Graded.Heap.Reduction._‚áí‚Çô_

-- A stack consisting only of (a given number of) successor
-- continuations

suc·µè = Graded.Heap.Untyped.suc‚Çõ

-- The reduction relations are deterministic

‚áæ-det = Graded.Heap.Reduction.Properties.‚áæ-det
‚á¢-det = Graded.Heap.Reduction.Properties.‚á¢-det
‚Ü†-det = Graded.Heap.Reduction.Properties.‚Ü†-det

-- The full semantics of the machine

_‚Ü†_ = Graded.Heap.Reduction._‚Ü†_

-- Reduction can fail in three different ways
--
-- Due to the formalization including natrec, this property does not
-- hold quite as stated. The linked property contains an additional
-- assumption that the stack does not contain any continuations
-- corresponding to natrec.

Final-reasons = Graded.Heap.Reduction.Properties.nr‚àâ-Final-reasons‚Ä≤

------------------------------------------------------------------------
-- 3.3: Usage for the Machine

-- Usage for heaps
--
-- The usage relation for heaps includes an additional rule not
-- mentioned in the paper related to dummy entries. In this section,
-- heaps are assumed to not have such entries so this rule cannot apply.
-- This case is discussed in the extended version.

_‚ñ∏ ∞_ = Graded.Heap.Usage._‚ñ∏ ∞_

-- Usage for continuations
--
-- The usage relation for continuations includes additional rules
-- corresponding to the eliminators not included in this section or the
-- paper. The case for natrec is discussed in Section¬†4.
--
-- In the paper the mode is written as a superscript. In the
-- formalization it is written inside brackets.

_‚ñ∏·∂ú[_]_ = Graded.Heap.Usage._‚ñ∏·∂ú[_]_

-- Usage for Stacks
--
-- The usage rule for non-empty stacks contains the assumption that the
-- stack multiplicity exists. As mentioned in the paper, this assumption
-- is implicit there.

_‚ñ∏À¢_ = Graded.Heap.Usage._‚ñ∏À¢_

-- Usage for states
--
-- The usage rule contains the assumption that the stack multiplicity
-- exists. As mentioned in the paper, this assumption is implicit there.

‚ñ∏_ = Graded.Heap.Usage.‚ñ∏_

-- Lemma 3.3: Heap lookups in well-resourced heaps yield well-resourced
-- entries and well-resourced updated heaps.

well-resourced-lookup = Graded.Heap.Usage.Properties.‚ñ∏-heapLookup

-- Theorem 3.4: Usage preservation for the abstract machine

‚ñ∏-‚áæ = Graded.Heap.Usage.Reduction.‚ñ∏-‚áæ
‚ñ∏-‚áæ* = Graded.Heap.Usage.Reduction.‚ñ∏-‚áæ*

-- Theorem 3.5: Heap lookups succeed for well-resourced heaps
--
-- This theorem is stated with an additional assumption that the stack
-- multiplicity exists. In the paper this assumption is implicit.

heap-lookup-succeeds = Graded.Heap.Usage.Properties.‚ñ∏‚Ü¶[]-closed

-- Reduction cannot fail due to failing heap lookups.
--
-- In the formalization, this is stated as there being two ways
-- reduction can fail. Of the original three reasons mentioned earlier,
-- the case for states with variables in head position is no longer
-- possible.

‚ñ∏Final-reasons = Graded.Heap.Usage.Reduction.‚ñ∏Final-reasons-closed

------------------------------------------------------------------------
-- 3.4: Typing for the Machine

-- Typing for heaps.
--
-- The formalized version of this judgment is the one which includes
-- support for evaluating open programs. There,
-- the judgment mentions an additional context which does not appear in
-- this section. For heaps without dummy entries, which is the case in
-- this section, one can show that this context is always empty.
--
-- The judgment has an additional case related to dummy entries. In this
-- section, heaps are assumed to not contain dummy entries so this rule
-- does not apply.

‚ä¢ ∞_‚à∑_ = Graded.Heap.Typed._‚ä¢ ∞_‚à∑_

-- Typing for continuations
--
-- As for heaps, the formalized judgment contains an additional context.
-- For the theory presented in this section, this context is empty.
--
-- The typing relation for continuations includes additional rules
-- corresponding to the eliminators not included in this section or the
-- paper. The case for natrec is discussed in Section¬†4.

_‚ä¢·∂ú_‚ü®_‚ü©‚à∑_‚Üù_ = Graded.Heap.Typed._‚®æ_‚ä¢·∂ú_‚ü®_‚ü©‚à∑_‚Üù_

-- Typing for stacks
--
-- Again, the formalized judgment contains an additional context.
-- For the theory presented in this section, this context is empty.

_‚ä¢_‚ü®_‚ü©‚à∑_‚Üù_ = Graded.Heap.Typed._‚®æ_‚ä¢_‚ü®_‚ü©‚à∑_‚Üù_

-- Typing for states
--
-- Again, the formalized judgment contains an additional context.
-- For the theory presented in this section, this context is empty.

‚ä¢‚Çõ_‚à∑_ = Graded.Heap.Typed._‚ä¢‚Çõ_‚à∑_

-- Well-typed states are well-typed when translated back into terms

‚ä¢‚¶Ö‚¶Ü = Graded.Heap.Typed.Properties.‚ä¢‚¶Ö‚¶Ü

-- Theorem 3.6: Type preservation for the abstract machine

‚ä¢-‚áæ = Graded.Heap.Typed.Reduction.‚ä¢‚Çõ-‚áæ
‚ä¢-‚áæ* = Graded.Heap.Typed.Reduction.‚ä¢‚Çõ-‚áæ*

-- Theorem 3.7: Values in non-empty stacks always reduce.
--
-- In the formalization, this theorem additionally assumes that the
-- stack multiplicity exists. As have been discussed above, this is the
-- case for the theory presented in this section.

‚ä¢Value-‚áí·µ• = Graded.Heap.Typed.Reduction.‚ä¢Value-‚áí·µ•

-- Theorem 3.8: For well-typed and well-resourced states, reduction
-- terminates only for states with value in head position and an empty
-- stack.

‚ä¢‚ñ∏Final-reasons = Graded.Heap.Termination.‚ä¢‚ñ∏Final-reasons-closed

------------------------------------------------------------------------
-- 3.5: Bisimilarity and Termination
--
-- Some properties in this section are stated in the paper for empty
-- contexts whereas the formalized versions hold also for non-empty
-- contexts.

-- Theorem 3.9: Reduction in the abstract machine implies reduction in
-- the call-by-name reduction.

-- The reduction for eliminators and variables corresponds to zero steps
-- in the call-by-name reduction.

‚áí‚Çë‚Üí‚â° = Graded.Heap.Reduction.Properties.‚áæ‚Çë-‚¶Ö‚¶Ü-‚â°

-- The reduction for values corresponds to one step in the call-by-name
-- reduction.

‚áí·µ•‚Üí‚áí = Graded.Heap.Typed.Reduction.‚áí·µ•‚Üí‚áí

-- The weak-head machine reduction corresponds to the call-by-name
-- reduction.

‚áæ‚Üí‚ä¢‚áí = Graded.Heap.Bisimilarity.‚áæ‚Üí‚ä¢‚áí

-- The reflexive, transitive closure of the weak-head machine reduction
-- corresponds to the call-by-name reduction.

‚áæ*‚Üí‚ä¢‚áí* = Graded.Heap.Bisimilarity.‚áæ*‚Üí‚ä¢‚áí*

-- States in normal form
--
-- The definition stated here additionally includes states for which
-- lookup yields a dummy entry to be in normal form. This is not
-- applicable for the theory presented in this section.

Normal = Graded.Heap.Untyped.Normal

-- Theorem 3.10: Bisimilarity between the tracking and non-tracking
-- reductions.

-- Reduction with the tracking semantics implies reduction in the
-- non-tracking semantics.

‚áæ‚Üí‚á¢ = Graded.Heap.Bisimilarity.‚áæ‚Üí‚á¢

-- Reduction with the non-tracking semantics implies reduction in the
-- tracking semantics for well-resourced states.

‚á¢‚Üí‚áæ = Graded.Heap.Bisimilarity.‚á¢‚Üí‚áæ

-- Theorem 3.11: Evaluation to normal form

normalize = Graded.Heap.Normalization.normalize
‚ñ∏normalize = Graded.Heap.Bisimilarity.‚ñ∏normalize

-- Theorem 3.12: Evaluation for values corresponds to evaluation in the
-- call-by-name reduction.
--
-- This property assumes that the stack multiplicity exists. As
-- discussed above, this is the case for the theory presented in this
-- section.

‚ä¢‚áí‚Üí‚áí·µ• = Graded.Heap.Bisimilarity.‚ä¢‚áí‚Üí‚áí·µ•

-- Theorem 3.13: Reduction in the call-by-name semantics implies
-- reduction in the abstract machine.

-- The first part of the theorem, for which evaluation is not
-- necessarily to a term in WHNF:

‚ä¢‚áí‚Üí‚áæ* = Graded.Heap.Bisimilarity.‚ä¢‚áí‚Üí‚áæ*

-- The second part, for evaluation to a term in WHNF:

‚ä¢‚áí‚Üí‚áæ*-whnf = Graded.Heap.Termination.whBisim-closed

-- Corollary 3.14: Termination of the weak-head reduction.

termination = Graded.Heap.Termination.‚ä¢‚ñ∏-‚áò-closed

------------------------------------------------------------------------
-- Resource Correctness

-- Bisimilarity does not hold if stacks are allowed to contain
-- successor continuations.

¬¨suc‚Çë-bisim = Graded.Heap.Typed.Reduction.¬¨suc‚Çë-‚áí·µ•‚Üí‚áí

-- Lemma 3.15: Adding successor continuations to the bottom of a stack
-- preserves reduction.

++suc‚Çõ-‚Ü†* = Graded.Heap.Reduction.Properties.++suc‚Çõ-‚Ü†*

-- Theorem 3.16: Evaluation to numerals

redNumeral = Graded.Heap.Soundness.redNumeral-closed

-- Theorem 3.17: Resource correctness
--
-- The grade associated with each entry in the heap being bounded by ùüò
-- is expressed using the relation _‚â§ ∞_ which relates a heap to a grade.
-- H¬†‚â§ ∞¬†p is inhabited iff the grade associated with each entry is less
-- than p.

resourceCorrectness = Graded.Heap.Soundness.soundness-closed

_‚â§ ∞_ = Graded.Heap.Usage._‚â§ ∞_

-- Resource correctness for open terms.
--
-- The formalized statement also disallows erased matches for
-- eliminators related to identity types.

resourceCorrectnessOpen =
  Graded.Heap.Soundness.soundness-open-consistent

-- Example: Projection function for weak Œ£-types

-- The projection function.

proj‚ÇÅ = Graded.Heap.Examples.fst ∑

-- Two entries are added to the heap during evaluation

proj‚ÇÅ‚Ü†‚ÇÅ = Graded.Heap.Examples.fst ∑‚ü®0,0‚ü©‚Ü†*‚Ä≤

-- The complete evaluation of the example

proj‚ÇÅ‚Ü†‚ÇÇ = Graded.Heap.Examples.fst ∑‚ü®0,0‚ü©‚Ü†*

¬¨‚ñ∏proj‚ÇÅ = Graded.Heap.Examples.Linearity.fst ∑-no-usage

------------------------------------------------------------------------
-- 4: Usage Counting for Natural Number Recursion

------------------------------------------------------------------------
-- 4.1: Natrec-star

-- The alternative usage rule has problems related to linearity

alt-usage-bad =
  Graded.Modality.Instances.Linearity.Bad.No-dedicated-nr.‚ñ∏double

-- The natrec-star operator.
--
-- The usage rule using natrec-star is more general than the one
-- mentioned in the paper and is based on the modality providing a so
-- called nr-function which is assumed to satisfy certain properties.
-- any natrec-star operator is an instance of such an nr-function.

natrec-star = Graded.Modality.Has-star

natrec-star‚Üínr = Graded.Modality.Properties.Star.has-nr

-- The problems we describe hold both for the usage relation with modes
-- and the one without modes. Note that this module is parametrized
-- over a Modality-variant

usage-bad-linearity = Graded.Modality.Instances.Linearity.Bad.‚ñ∏double

-- Addition for natural numbers

plus = Graded.Modality.Instances.Examples.plus‚Ä≤

-- Natrec-star for the linear types modality

‚äõ-linearity = Graded.Modality.Instances.Zero-one-many._‚äõ_‚ñ∑_

-- This is the greatest lawful natrec-star operator

‚äõ-linearity-greatest =
  Graded.Modality.Instances.Zero-one-many.‚äõ-greatest

-- A usage rule for plus

‚ñ∏plus = Graded.Modality.Instances.Linearity.Bad.‚ñ∏plus‚Ä≤

-- The usage for adding two variables

‚ñ∏plus-x‚ÇÄ-x‚ÇÅ = Graded.Modality.Instances.Linearity.Bad.‚ñ∏plus‚Ä≤-x‚ÇÄ-x‚ÇÅ

-- The usage for adding a variable to itself

‚ñ∏plus-x‚ÇÄ-x‚ÇÄ = Graded.Modality.Instances.Linearity.Bad.‚ñ∏plus‚Ä≤-x‚ÇÄ-x‚ÇÄ

------------------------------------------------------------------------
-- 4.2: A Resource-Correct Usage Rule

-- Grade sequences
--
-- This defines sequences of any type.

Grade-sequence = Tools.Nat.Sequence

-- Greatest lower bounds of grade sequences

Greatest-lower-bound = Graded.Modality.Modality.Greatest-lower-bound

-- Greatest lower bounds of context sequences

Greatest-lower-bound·∂ú = Graded.Context.Greatest-lower-bound·∂ú

-- The usage rule for natrec
--
-- The rule in question is natrec-no-nr-glb‚Çò

‚ñ∏natrec = Graded.Usage._‚ñ∏[_]_

-- The function nr·µ¢

nr·µ¢ = Graded.Modality.Modality.nr·µ¢

-- The function nr·µ¢ lifted to contexts

nr·µ¢·∂ú = Graded.Context.Properties.Natrec.nr·µ¢·∂ú

-- Definition 4.1: Modalities with well-behaved greatest lower bounds
--
-- This property is defined for Semiring-with-meet

Well-behaved-GLB = Graded.Modality.Has-well-behaved-GLBs

-- A sub-interchange law for addition and meet

+-sub-interchangeable-‚àß =
  Graded.Modality.Properties.Addition.+-sub-interchangeable-‚àß

-- The example modalities have well-behaved greatest lower bounds
--
-- Note that the proof for the linear types and affine types instances
-- link to the same property since it is proven independently of the
-- choice of partial order.

erasure-well-behaved-GLB =
  Graded.Modality.Instances.Erasure.Properties.Erasure-supports-factoring-nr-rule
affine-well-behaved-GLB =
  Graded.Modality.Instances.Zero-one-many.zero-one-many-supports-glb-for-natrec
linearity-well-behaved-GLB =
  Graded.Modality.Instances.Zero-one-many.zero-one-many-supports-glb-for-natrec
‚Ñïœâ-well-behaved-GLB =
  Graded.Modality.Instances.Nat-plus-infinity.‚Ñï‚äé‚àû-supports-glb-for-natrec

-- Subject reduction

subject-reduction = Graded.Reduction.usagePresTerm

-- The characteristic inequalities of greatest lower bounds of nr·µ¢

nr·µ¢-‚â§‚ÇÅ = Graded.Modality.Properties.Natrec.nr·µ¢-GLB-‚â§‚ÇÄ
nr·µ¢-‚â§‚ÇÇ = Graded.Modality.Properties.Natrec.nr·µ¢-GLB-‚â§

-- The substitution lemma

subst-lemma = Graded.Substitution.Properties.subst‚Çò-lemma

-- Correctness for erasure

erasure-correct =
  Graded.Erasure.Consequences.Soundness.Soundness.soundness-‚Ñï

-- A usage rule for plus for the linear types modality

‚ñ∏plus‚Ä≤ =
  Graded.Modality.Instances.Linearity.Good.Greatest-lower-bound.‚ñ∏plus‚Ä≤

-- The usage rule for plus simplified

‚ñ∏plus‚Ä≥ =
  Graded.Modality.Instances.Linearity.Good.Greatest-lower-bound.‚ñ∏plus‚Ä≥

------------------------------------------------------------------------
-- 4.3: Resource Correctness for the Natural Number Eliminator

-- Multiplicity of a continuation

‚à£_‚à£·∂ú‚â°‚Ä≤_ = Graded.Heap.Untyped.‚à£_‚à£·∂ú‚â°_

-- The greatest lower bound does not exist for all nr·µ¢ sequences for
-- all modalities. This example is the modality of natural numbers
-- (without œâ).

¬¨nr·µ¢-GLB = Graded.Modality.Instances.Nat.¬¨nr·µ¢-GLB

-- This instance has a well-behaved zero, supports subtraction and
-- has well-behaved greatest lower bounds.

Nat-well-behaved-zero =
  Graded.Modality.Instances.Nat.Nat-has-well-behaved-zero
Nat-subtraction =
  Graded.Modality.Instances.Nat.supports-subtraction
Nat-well-behaved-GLB =
  Graded.Modality.Instances.Nat.Nat-has-well-behaved-GLBs

-- The stack multiplicity does not necessarily exist

‚à£‚à£‚â¢ = Graded.Heap.Untyped.Properties.‚à£‚à£‚â¢

-- The stack multiplicity is functional

‚à£‚à£-functional‚Ä≤ = Graded.Heap.Untyped.Properties.‚à£‚à£-functional

-- The greatest lower bound of grade sequences is unique if it exists

GLB-unique = Graded.Modality.Properties.Greatest-lower-bound.GLB-unique

-- Applying a term to a continuation

‚¶Ö_‚¶Ü·∂ú‚Ä≤_ = Graded.Heap.Untyped.‚¶Ö_‚¶Ü·∂ú_

-- The reduction of eliminators and variables is updated

_‚áæ‚Çë‚Ä≤_ = Graded.Heap.Reduction._‚áæ‚Çë_

-- In particular, the auxiliary reduction is updated.

_‚áí‚Çë‚Ä≤_ = Graded.Heap.Reduction._‚áí‚Çë_

-- Reduction of values is also updated.

_‚áí·µ•‚Ä≤_ = Graded.Heap.Reduction._‚áí·µ•_

-- The reduction relations are deterministic

‚áæ-det‚Ä≤ = Graded.Heap.Reduction.Properties.‚áæ-det
‚á¢-det‚Ä≤ = Graded.Heap.Reduction.Properties.‚á¢-det
‚Ü†-det‚Ä≤ = Graded.Heap.Reduction.Properties.‚Ü†-det

-- The usage for continuations is extended

_‚ñ∏·∂ú[_]‚Ä≤_ = Graded.Heap.Usage._‚ñ∏·∂ú[_]_

-- The stack multiplicity always exist for well-resourced states

‚ñ∏‚à£‚à£‚â° = Graded.Heap.Usage.Inversion.‚ñ∏‚Çõ-inv

-- Well-resourced states do not get stuck due to non-existing stack
-- multiplicity
--
-- In the formalization, this is stated as there being two ways
-- reduction can fail. Of the original three reasons mentioned earlier,
-- the case for states with variables in head position is no longer
-- possible.

‚ñ∏Final-reasons‚Ä≤ = Graded.Heap.Usage.Reduction.‚ñ∏Final-reasons-closed

-- The typing relation for continuations is extended

_‚ä¢·∂ú_‚ü®_‚ü©‚à∑_‚Üù‚Ä≤_ = Graded.Heap.Typed._‚®æ_‚ä¢·∂ú_‚ü®_‚ü©‚à∑_‚Üù_

------------------------------------------------------------------------
-- 4.4: Usage Counting for the Natural Number Eliminator

-- For the example modalities the greatest lower bound of nr·µ¢¬†r¬†p¬†q
-- always exists.
--
-- Note that the proof for the linear types and affine types instances
-- link to the same property since it is proven independently of the
-- choice of partial order.

erasure-GLB-nr·µ¢ =
  Graded.Modality.Instances.Erasure.Properties.Erasure-nr·µ¢-glb
affine-GLB-nr·µ¢ =
  Graded.Modality.Instances.Zero-one-many.nr-nr·µ¢-GLB
linear-GLB-nr·µ¢ =
  Graded.Modality.Instances.Zero-one-many.nr-nr·µ¢-GLB
‚Ñïœâ-GLB-nr·µ¢ =
  Graded.Modality.Instances.Nat-plus-infinity.nr·µ¢-GLB

-- For modalities with a well-behaved zero, the greatest lower bound
-- of any grade sequence is zero only if the sequence is constantly
-- zero.
--
-- Note that this applies to the linear and affine types modalities.

ùüò-GLB = Graded.Modality.Properties.Greatest-lower-bound.ùüò-GLB-inv

-- For the linear types modality, the greatest lower bound
-- of any grade sequence is one only if the sequence is constantly
-- one.

ùüô-GLB-linear = Graded.Modality.Instances.Linearity.ùüô-GLB-inv

-- For the linear types modality, the greatest lower bound
-- of any grade sequence is one only if the sequence only consists
-- of grades zero and one.

ùüô-GLB-affine = Graded.Modality.Instances.Linearity.ùüô-GLB-inv

-- For both the linear and affine types modalities, ùüò is the greatest
-- lower bound of nr·µ¢¬†r¬†p¬†q only if p¬†‚â°¬†ùüò and q¬†‚â°¬†ùüò

ùüò-GLB-nr·µ¢-linearity = Graded.Modality.Instances.Linearity.nr·µ¢-GLB-ùüò-inv
ùüò-GLB-nr·µ¢-affine = Graded.Modality.Instances.Affine.nr·µ¢-GLB-ùüò-inv

-- For the affine types modality, the greatest lower bound of nr·µ¢¬†r¬†p¬†q
-- is one only in some cases.

ùüô-GLB-nr·µ¢-linearity = Graded.Modality.Instances.Linearity.nr·µ¢-GLB-ùüô-inv

-- For the affine types modality, the greatest lower bound of nr·µ¢¬†r¬†p¬†q
-- is one only in some cases.

ùüô-GLB-nr·µ¢-affine = Graded.Modality.Instances.Affine.nr·µ¢-GLB-ùüô-inv

-- For the linear types modality, the greatest lower bound of nr·µ¢¬†r¬†ùüô¬†p
-- is ùüô only if r¬†‚â°¬†ùüò and p¬†‚â°¬†ùüô or r¬†‚â°¬†ùüô and p¬†‚â°¬†ùüò.
-- In other words, the natural number argument to natrec is used
-- linearly only in these cases

natrec-linear = Graded.Modality.Instances.Linearity.nr·µ¢-rùüôp-GLB-ùüô-inv

-- The predecessor function

pred = Graded.Modality.Instances.Examples.pred‚Ä≤

-- A usage rule for the predecessor function

‚ñ∏pred = Graded.Modality.Instances.Linearity.Good.Greatest-lower-bound.‚ñ∏pred‚Ä≤

-- For the affine types modality, the greatest lower bound of nr·µ¢¬†r¬†ùüô¬†p
-- is ùüô only if r¬†‚â°¬†ùüò and p¬†‚â°¬†ùüô or r¬†‚â°¬†ùüô and p¬†‚â°¬†ùüò or r¬†‚â°¬†ùüò and p¬†‚â°¬†ùüò
-- In other words, the natural number argument to natrec is used
-- in an affine way only in these cases

natrec-affine = Graded.Modality.Instances.Affine.nr·µ¢-rùüôp-GLB-ùüô-inv

-- The natural number argument is never considered to be erased. I.e.
-- the greatest lower bound of nr·µ¢¬†r¬†ùüô¬†p is never ùüò.

natrec-not-erased =
  Graded.Modality.Properties.Natrec.nr·µ¢-natrec-not-erased

-- For both the linear types and the affine types modalities, the
-- greatest lower bound of nr·µ¢¬†ùüò¬†p¬†q is p¬†‚àß¬†q.
-- In other words, the contribution of the zero and successor branches
-- of natrec¬†p‚Ä≤¬†q‚Ä≤¬†ùüò¬†A¬†z¬†s¬†n is Œ≥¬†‚àß¬†Œ¥ when Œ≥ ‚ñ∏ z and Œ¥,p,r‚ñ∏s

natrec-usage-ùüò = Graded.Modality.Instances.Zero-one-many.nr·µ¢-ùüò-GLB

-- For both the linear types and the affine types modalities, the
-- greatest lower bound of nr·µ¢¬†ùüô¬†p¬†q is p¬†+¬†œâ¬†¬∑¬†q.
-- In other words, the contribution of the zero and successor branches
-- of natrec¬†p‚Ä≤¬†q‚Ä≤¬†ùüô¬†A¬†z¬†s¬†n is Œ≥¬†+¬†œâ¬†¬∑¬†Œ¥ when Œ≥ ‚ñ∏ z and Œ¥,p,r‚ñ∏s

natrec-usage-ùüô = Graded.Modality.Instances.Zero-one-many.nr·µ¢-ùüô-GLB

-- For both the linear types and the affine types modalities, the
-- greatest lower bound of nr·µ¢¬†œâ¬†p¬†q is p¬†+¬†œâ¬†¬∑¬†q.
-- In other words, the contribution of the zero and successor branches
-- of natrec¬†p¬†q¬†œâ¬†A¬†z¬†s¬†n is œâ¬†¬∑(Œ≥¬†+¬†Œ¥) when Œ≥ ‚ñ∏ z and Œ¥,p,r‚ñ∏s

natrec-usage-œâ = Graded.Modality.Instances.Zero-one-many.nr·µ¢-œâ-GLB

------------------------------------------------------------------------
-- 5: Resource Correctness for Open Programs

-- The definition of heap substitutions is extended

‚¶Ö_‚¶Ü ∞‚Ä≤ = Graded.Heap.Untyped.toSubst‚Çï

-- The definition of initial state is updated

initial‚Ä≤ = Graded.Heap.Untyped.initial

-- Reduction can fail in three different ways

Final-reasons-open = Graded.Heap.Reduction.Properties.Final-reasons

-- Typing judgments:

-- Typing for heaps

‚ä¢ ∞_‚à∑‚Ä≤_ = Graded.Heap.Typed._‚ä¢ ∞_‚à∑_

-- Typing for continuations

_‚ä¢·∂ú_‚ü®_‚ü©‚à∑_‚Üù‚Ä≥_ = Graded.Heap.Typed._‚®æ_‚ä¢·∂ú_‚ü®_‚ü©‚à∑_‚Üù_

-- Typing for stacks

_‚ä¢_‚ü®_‚ü©‚à∑_‚Üù‚Ä≤_ = Graded.Heap.Typed._‚®æ_‚ä¢_‚ü®_‚ü©‚à∑_‚Üù_

-- Typing for states

‚ä¢‚Çõ_‚à∑‚Ä≤_ = Graded.Heap.Typed._‚ä¢‚Çõ_‚à∑_

-- Type preservation for the abstract machine

‚ä¢-‚áæ‚Ä≤ = Graded.Heap.Typed.Reduction.‚ä¢‚Çõ-‚áæ
‚ä¢-‚áæ*‚Ä≤ = Graded.Heap.Typed.Reduction.‚ä¢‚Çõ-‚áæ*

-- Values in non-empty stacks always reduce.

‚ä¢Value-‚áí·µ•‚Ä≤ = Graded.Heap.Typed.Reduction.‚ä¢Value-‚áí·µ•

-- Usage preservation for the abstract machine

‚ñ∏-‚áæ‚Ä≤ = Graded.Heap.Usage.Reduction.‚ñ∏-‚áæ
‚ñ∏-‚áæ*‚Ä≤ = Graded.Heap.Usage.Reduction.‚ñ∏-‚áæ*

-- Well-resourced dummy entries are assigned grade ùüò

‚ñ∏H‚óè = Graded.Heap.Usage.Properties.‚ñ∏H‚óè

-- Lookups to dummy entries can only occur if the stack multiplicity is ùüò

‚ñ∏s‚óè = Graded.Heap.Usage.Properties.‚ñ∏s‚óè

-- The stack multiplicity is zero iff it contains erased prodrec,
-- unitrec or emptyrec.
--
-- The second direction, showing that the stack contains erased prodrec,
-- unitrec, or emptyrec if the stack multiplicity is zero does not
-- necessarily hold if the stack contains continuations related to the
-- identity type since these can have multiplicity zero. In the linked
-- property, we have shown that the stack contains erased prodrec,
-- unitrec or emptyrec or a continuation related the identity type (J, K,
-- or []-cong).

‚à£‚à£‚â°ùüò-if-erased-elim‚Ä≤ = Graded.Heap.Untyped.Properties.‚à£‚à£‚â°ùüò
erased-elim-if-‚à£‚à£‚â°ùüò‚Ä≤ = Graded.Heap.Untyped.Properties.‚à£‚à£‚â°ùüò‚Üíerased-match

-- The multiplicity of the continuation for natrec is never ùüò

‚à£nr‚à£‚â¢ùüò = Graded.Heap.Untyped.Properties.‚à£nr‚à£‚â¢ùüò

-- Theorem 5.1: Heap lookups succeed for well-resourced heaps

heap-lookup-succeeds‚Ä≤ = Graded.Heap.Soundness.lookup-succeeds‚Ä≤

-- States in normal form

Normal‚Ä≤ = Graded.Heap.Untyped.Normal

-- Theorem 5.2: Resource correctness for open terms.
--
-- The formalized statement also disallows erased matches for
-- eliminators related to identity types.

resourceCorrectnessOpen‚Ä≤ =
  Graded.Heap.Soundness.soundness-open-consistent

-- Counterexamples to the resource correctness theorem when some
-- assumptions are removed.
-- These countrexamples are constructed under the assumption that some
-- function types are allowed (as given by the type restrictions).

-- Inconsistent contexts

¬¨resource-correctness-inconsistent =
  Graded.Heap.Soundness.Counterexample.¬¨soundness-inconsistent

-- Erased matches for unitrec

¬¨resource-correctness-erased-matches-unitrec =
  Graded.Heap.Soundness.Counterexample.¬¨soundness-erased-matches-unitrec

-- Erased matches for prodrec

¬¨resource-correctness-erased-matches-prodrec =
  Graded.Heap.Soundness.Counterexample.¬¨soundness-erased-matches-prodrec

-- Programs using free variables in a non-erased way

¬¨resource-correctness-non-erased =
  Graded.Heap.Soundness.Counterexample.¬¨soundness-not-erased

-- A version of resource correctness with no erased matches for
-- emptyrec.

resourceCorrectnessOpen‚Ä≥ =
  Graded.Heap.Soundness.soundness-open-¬¨emptyrec‚ÇÄ

------------------------------------------------------------------------
-- 7: Related Work

-- For erasure, the context in the contexts in the conclusions of the
-- usage rules for natrec using natrec-star and greatest lower bounds
-- coincide

Erasure-‚äõ‚â°GLB = Graded.Modality.Instances.Erasure.Properties.‚ñ∏‚äõ‚âàGLB
